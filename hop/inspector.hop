<import component="side-bar" from="hop/ui">
<import component="side-bar-group" from="hop/ui">

<canvas-view class="w-full h-full">
	<div data-id="canvas" style="width: 0; height: 0;">
		<slot-default />
	</div>
	
	<script>
		const MIN_ZOOM = 0.1;
		const MAX_ZOOM = 5.0;

		const canvas = frameElement.querySelector('[data-id="canvas"]');

		class Matrix {
			constructor(mat) {
				this.mat = mat;
				this.persist();
			}
			update(fn) {
				this.mat = fn(this.mat);
				this.persist();
			}
			get() {
				return this.mat;
			}
			persist() {
				const result = this.mat.toString();
				canvas.style.transform = result;
				localStorage.setItem('hop-inspector-transform-matrix', result);
				window.canvasMatrix = this.mat;
			}
		}
		
		let mat = new Matrix(restoreFromLocalStorage());
		
		function handleScrollWheel() {
			frameElement.addEventListener('wheel', (e) => {
				if (e.ctrlKey) {
					// Zoom with Ctrl+scroll
					e.preventDefault();
					
					const scaleFactor = e.deltaY > 0 ? 0.85 : 1.15;
					
					// Get mouse position relative to the canvas wrapper
					// and convert to canvas coords
					const rect = frameElement.getBoundingClientRect();
					const point = new DOMPointReadOnly(
						e.clientX - rect.left,
						e.clientY - rect.top
					);
					const center = mat.get().inverse().transformPoint(point);
					
					mat.update(m => {
						return m.translate(center.x, center.y)
								.scale(scaleFactor)
								.translate(-center.x, -center.y);
					});

				} else {
					// Pan with touchpad or mouse wheel
					e.preventDefault();
					const panSpeed = 0.7;
					
					// Check if it's a touchpad gesture (has both deltaX and deltaY)
					// or if deltaX is non-zero (horizontal scroll)
					if (e.deltaX !== 0 || e.shiftKey) {
						// Horizontal panning
						const deltaX = e.shiftKey ? -e.deltaY * panSpeed : -e.deltaX * panSpeed;
						const deltaY = e.shiftKey ? 0 : -e.deltaY * panSpeed;
						mat.update(m => m.translate(deltaX, deltaY));
					} else {
						// Vertical panning only
						const deltaY = -e.deltaY * panSpeed;
						mat.update(m => m.translate(0, deltaY));
					}
				}
			}, { passive: false });
		}
		handleScrollWheel();
	
		function handlePanning() {

			let spacePressed = false;
			let isPanning = false;
			let panStartX = 0;
			let panStartY = 0;
			let panStartMatrix = null;

			document.addEventListener('keydown', (e) => {
				if (e.code === 'Space' && !spacePressed && !e.target.matches('input, textarea, [contenteditable]')) {
					e.preventDefault();
					spacePressed = true;
					document.body.style.setProperty('cursor', 'grab', 'important');
				}
			});

			document.addEventListener('keyup', (e) => {
				if (e.code === 'Space') {
					spacePressed = false;
					isPanning = false;
					document.body.style.removeProperty('cursor');
				}
			});

			// Handle window blur to reset space key state
			window.addEventListener('blur', () => {
				spacePressed = false;
				isPanning = false;
				document.body.style.removeProperty('cursor');
			});

			document.addEventListener('mousedown', (e) => {
				if (spacePressed && e.button === 0) {
					e.preventDefault();
					isPanning = true;
					panStartX = e.clientX;
					panStartY = e.clientY;
					panStartMatrix = new DOMMatrix(mat.get());
					document.body.style.setProperty('cursor', 'grabbing');
				}
			});
			
			document.addEventListener('mousemove', (e) => {
				if (isPanning && spacePressed) {
					const deltaX = e.clientX - panStartX;
					const deltaY = e.clientY - panStartY;
					mat.update(() => panStartMatrix.translate(deltaX, deltaY));
				}
			});
			
			document.addEventListener('mouseup', (e) => {
				if (isPanning) {
					isPanning = false;
					if (spacePressed) {
						document.body.style.setProperty('cursor', 'grab', 'important');
					} else {
						document.body.style.removeProperty('cursor');
					}
				}
			});

		}
		handlePanning();

		function restoreFromLocalStorage() {
			const savedMatrix = localStorage.getItem('hop-inspector-transform-matrix');
			if (savedMatrix) {
				try {
					return new DOMMatrix(savedMatrix);
				} catch (e) {
					return new DOMMatrix();
				}
			}
			return new DOMMatrix();
		}
		
	</script>
</canvas-view>

<!---------------------------------------------------------------------------->

<canvas-element {preview: string} style="position: absolute;">
	<div class="flex flex-col gap-1 relative group p-4" data-id="resizable-container">
		<div class="flex justify-between items-center">
			<div data-id="title-area">
				<slot-title />
			</div>
			<button data-id="bg-toggler" class="bg-white border border-2 size-4"></button>
		</div>
		<div class="bg-white" data-id="iframe-wrapper">
			<iframe set-src="preview" style="width: 100%; height: 480px; border: none;" title="Component Preview"></iframe>
		</div>
		<!-- Resize handles -->
		<div data-id="resize-handle-se" class="absolute bottom-0 right-0 w-4 h-4 bg-gray-500 border border-white cursor-se-resize opacity-0 group-hover:opacity-70 hover:!opacity-100 rounded-sm transition-opacity duration-200"></div>
		<div data-id="resize-handle-s" class="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-8 h-3 bg-gray-500 border border-white cursor-s-resize opacity-0 group-hover:opacity-70 hover:!opacity-100 rounded-sm transition-opacity duration-200"></div>
		<div data-id="resize-handle-e" class="absolute right-0 top-1/2 transform -translate-y-1/2 w-3 h-8 bg-gray-500 border border-white cursor-e-resize opacity-0 group-hover:opacity-70 hover:!opacity-100 rounded-sm transition-opacity duration-200"></div>
	</div>
	<script>
		/* Note that frameElement is the div that represents the <canvas-element> */
		const wrapper = frameElement.querySelector('[data-id="iframe-wrapper"]');
		const bgToggler = frameElement.querySelector('[data-id="bg-toggler"]');
		const titleArea = frameElement.querySelector('[data-id="title-area"]');
		const iframe = frameElement.querySelector('iframe');
		const container = frameElement.querySelector('[data-id="resizable-container"]');
		const resizeHandleSE = frameElement.querySelector('[data-id="resize-handle-se"]');
		const resizeHandleS = frameElement.querySelector('[data-id="resize-handle-s"]');
		const resizeHandleE = frameElement.querySelector('[data-id="resize-handle-e"]');
		
		// Coordinate transformation utilities
		function getCanvasMatrix() {
			return window.canvasMatrix;
		}
		
		function screenToCanvas(screenX, screenY) {
			const mat = getCanvasMatrix();
			const point = new DOMPointReadOnly(
				screenX,
				screenY
			);
			return mat.inverse().transformPoint(point);
		}
		
		// Background toggle functionality
		bgToggler.addEventListener('click', () => {
			bgToggler.classList.toggle('bg-white');
			bgToggler.classList.toggle('bg-transparent');
			wrapper.classList.toggle('bg-white');
			wrapper.classList.toggle('bg-transparent');
			wrapper.classList.toggle('outline');
		});
		
		// Draggable functionality by dragging the title area
		function handleDragging() {
			titleArea.style.cursor = 'move';
			let isDragging = false;
			let startX;
			let startY;
			
			titleArea.addEventListener('mousedown', (e) => {
				isDragging = true;
				
				// Get current mouse position in canvas coordinates
				const currentMouseCanvas = screenToCanvas(e.clientX, e.clientY);
				
				// Get current element position (already in canvas space)
				const currentLeft = parseFloat(frameElement.style.left) || 0;
				const currentTop = parseFloat(frameElement.style.top) || 0;
				
				// Calculate offset from mouse to element origin
				startX = currentMouseCanvas.x - currentLeft;
				startY = currentMouseCanvas.y - currentTop;
				
				frameElement.style.opacity = '0.5';
				
				// Disable pointer events on all iframes to prevent drag interference
				document.querySelectorAll('iframe').forEach((frm) => {
					frm.style.pointerEvents = 'none';
				})
				
				e.preventDefault();
			});
			
			document.addEventListener('mousemove', (e) => {
				if (isDragging) {
					// Convert screen coordinates to canvas coordinates for positioning
					const canvasCoords = screenToCanvas(e.clientX, e.clientY);
					frameElement.style.left = (canvasCoords.x - startX) + 'px';
					frameElement.style.top = (canvasCoords.y - startY) + 'px';
				}
			});
			
			document.addEventListener('mouseup', () => {
				if (isDragging) {
					isDragging = false;
					frameElement.style.opacity = '1';
					
					// Re-enable pointer events on iframes
					document.querySelectorAll('iframe').forEach((frm) => {
						frm.style.pointerEvents = 'auto';
					});
					
					saveElementState();
				}
			});
		}
		handleDragging();
	
		// Resize functionality
		function handleResize() {
			let isResizing = false;
			let resizeType = '';
			let resizeStartX, resizeStartY, startWidth, startHeight;
			
			function initResize(e, type) {
				isResizing = true;
				resizeType = type;
				
				// Convert screen coordinates to canvas coordinates
				const canvasCoords = screenToCanvas(e.clientX, e.clientY);
				resizeStartX = canvasCoords.x;
				resizeStartY = canvasCoords.y;
				
				startWidth = frameElement.offsetWidth;
				startHeight = frameElement.offsetHeight;
				
				// Disable pointer events on iframe during resize
				document.querySelectorAll('iframe').forEach((frm) => {
					frm.style.pointerEvents = 'none';
				});
				
				e.preventDefault();
				e.stopPropagation();
			}
			
			resizeHandleSE.addEventListener('mousedown', (e) => initResize(e, 'se'));
			resizeHandleS.addEventListener('mousedown', (e) => initResize(e, 's'));
			resizeHandleE.addEventListener('mousedown', (e) => initResize(e, 'e'));
			
			document.addEventListener('mousemove', (e) => {
				if (isResizing) {
					// Convert current mouse position to canvas coordinates
					const canvasCoords = screenToCanvas(e.clientX, e.clientY);
					const deltaX = canvasCoords.x - resizeStartX;
					const deltaY = canvasCoords.y - resizeStartY;
					
					if (resizeType.includes('e')) {
						const newWidth = startWidth + deltaX;
						frameElement.style.width = newWidth + 'px';
					}
					
					if (resizeType.includes('s')) {
						const newHeight = startHeight + deltaY;
						frameElement.style.height = newHeight + 'px';
						iframe.style.height = (newHeight - 60) + 'px'; // Adjust for header
					}
				}
			});
			
			document.addEventListener('mouseup', () => {
				if (isResizing) {
					isResizing = false;
					resizeType = '';
					
					// Re-enable pointer events on iframe
					document.querySelectorAll('iframe').forEach((frm) => {
						frm.style.pointerEvents = 'auto';
					});
					
					saveElementState();
				}
			});
		}
		handleResize();
		
		// localStorage functionality
		function getElementId() {
			const titleElement = frameElement.querySelector('[data-id="title-area"]');
			return titleElement ? titleElement.textContent.trim() : 'unknown-' + Math.random().toString(36).substr(2, 9);
		}
		
		function saveElementState() {
			const elementId = getElementId();
			const rect = frameElement.getBoundingClientRect();
			const state = {
				position: frameElement.style.position,
				left: frameElement.style.left,
				top: frameElement.style.top,
				width: frameElement.style.width,
				height: frameElement.style.height,
				iframeHeight: iframe.style.height
			};
			
			const savedStates = JSON.parse(localStorage.getItem('hop-inspector-states') || '{}');
			savedStates[elementId] = state;
			localStorage.setItem('hop-inspector-states', JSON.stringify(savedStates));
		}
		
		function restoreElementState() {
			const elementId = getElementId();
			const savedStates = JSON.parse(localStorage.getItem('hop-inspector-states') || '{}');
			const state = savedStates[elementId];
			
			if (state) {
				if (state.position) frameElement.style.position = state.position;
				if (state.left) frameElement.style.left = state.left;
				if (state.top) frameElement.style.top = state.top;
				if (state.width) frameElement.style.width = state.width;
				if (state.height) frameElement.style.height = state.height;
				if (state.iframeHeight) iframe.style.height = state.iframeHeight;
			}
		}
		
		// Initialize: restore state on load
		restoreElementState();
	</script>
	<hop-x-preview>
		<div class="p-8">
			<canvas-element {'/_preview/hop%2Ferror_pages/error-generic-error'}>
				<with-title>hop/ui - component</with-title>
			</canvas-element>
		</div>
	</hop-x-preview>
</canvas-element>

<!---------------------------------------------------------------------------->

<inspect-page {data: object[modules: array[object[name: string, components: array[object[name: string, has_preview: boolean, preview_url: string]]]], available_routes: array[string]]} entrypoint>
	<!DOCTYPE html>
	<html>
	<head>
		<title>hop dev - inspector</title>
		<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
		<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
        <style>
          body { font-family: "JetBrains Mono"; }
        </style>
	</head>
	<body class="bg-[#f6f6f6] h-screen w-screen" style="background: repeating-conic-gradient(rgba(0,0,0,0.025) 0 25%, rgba(0,0,0,0.05) 0 50%) 50% / 16px 16px;">
		<div class="flex">
			<div class="bg-white p-3 w-80 h-screen overflow-y-auto">
				<side-bar>
					<with-layers>
						<for {module in data.modules}>
							<side-bar-group>
								<with-title>
									{module.name}
								</with-title>
								<with-body>
									<for {component in module.components}>
										<div>
											{component.name}
										</div>
									</for>
								</with-body>
							</side-bar-group>
						</for>
					</with-layers>
				</side-bar>
			</div>
			<div class="flex-grow h-screen overflow-hidden">
				<canvas-view>
					<for {module in data.modules}>
						<for {component in module.components}>
							<if {component.has_preview}>
								<canvas-element {component.preview_url}>
									<with-title>{module.name} - {component.name}</with-title>
								</canvas-element>
							</if>
						</for>
					</for>
				</canvas-view>
			</div>
		</div>
	</body>
	</html>
</inspect-page>
