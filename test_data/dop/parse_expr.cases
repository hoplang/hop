## BEGIN
-- in --
a == b == c
-- out --
BinaryOp { left: BinaryOp { left: Variable { name: "a" }, operator: Equal, right: Variable { name: "b" } }, operator: Equal, right: Variable { name: "c" } }
## END

## BEGIN
-- in --
user.name == admin.name
-- out --
BinaryOp { left: PropertyAccess { object: Variable { name: "user" }, property: "name" }, operator: Equal, right: PropertyAccess { object: Variable { name: "admin" }, property: "name" } }
## END

## BEGIN
-- in --
app.user.profile.settings.theme
-- out --
PropertyAccess { object: PropertyAccess { object: PropertyAccess { object: PropertyAccess { object: Variable { name: "app" }, property: "user" }, property: "profile" }, property: "settings" }, property: "theme" }
## END

## BEGIN
-- in --
''
-- out --
StringLiteral { value: "" }
## END

## BEGIN
-- in --
42
-- out --
NumberLiteral { value: Number(42) }
## END

## BEGIN
-- in --
3.14
-- out --
NumberLiteral { value: Number(3.14) }
## END

## BEGIN
-- in --
user.profile.name
-- out --
PropertyAccess { object: PropertyAccess { object: Variable { name: "user" }, property: "profile" }, property: "name" }
## END

## BEGIN
-- in --
(x == y)
-- out --
BinaryOp { left: Variable { name: "x" }, operator: Equal, right: Variable { name: "y" } }
## END

## BEGIN
-- in --
user.name
-- out --
PropertyAccess { object: Variable { name: "user" }, property: "name" }
## END

## BEGIN
-- in --
'guest' == user.role
-- out --
BinaryOp { left: StringLiteral { value: "guest" }, operator: Equal, right: PropertyAccess { object: Variable { name: "user" }, property: "role" } }
## END

## BEGIN
-- in --
x == y
-- out --
BinaryOp { left: Variable { name: "x" }, operator: Equal, right: Variable { name: "y" } }
## END

## BEGIN
-- in --
'hello'
-- out --
StringLiteral { value: "hello" }
## END

## BEGIN
-- in --
x
-- out --
Variable { name: "x" }
## END

## BEGIN
-- in --
'apple' == 'orange'
-- out --
BinaryOp { left: StringLiteral { value: "apple" }, operator: Equal, right: StringLiteral { value: "orange" } }
## END

## BEGIN
-- in --
user.name == 'admin'
-- out --
BinaryOp { left: PropertyAccess { object: Variable { name: "user" }, property: "name" }, operator: Equal, right: StringLiteral { value: "admin" } }
## END

## BEGIN
-- in --
user.name == 'admin'
-- out --
BinaryOp { left: PropertyAccess { object: Variable { name: "user" }, property: "name" }, operator: Equal, right: StringLiteral { value: "admin" } }
## END

## BEGIN
-- in --
'hello world'
-- out --
StringLiteral { value: "hello world" }
## END

## BEGIN
-- in --
  user . name   ==   admin . name  
-- out --
BinaryOp { left: PropertyAccess { object: Variable { name: "user" }, property: "name" }, operator: Equal, right: PropertyAccess { object: Variable { name: "admin" }, property: "name" } }
## END

Parse error when expression has trailing tokens.

## BEGIN
-- in --
x y
-- out --
error: Unexpected token at end of expression
x y
  ^
## END

Parse error when dot is not followed by identifier.

## BEGIN
-- in --
user.
-- out --
error: Expected identifier after '.'
user.
     ^
## END

Parse error when dot is followed by a number.

## BEGIN
-- in --
user.123
-- out --
error: Expected identifier after '.'
user.123
     ^^^
## END

Parse error when expression starts with an invalid token.

## BEGIN
-- in --
== x
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
== x
^^
## END

Parse error with unclosed parenthesis.

## BEGIN
-- in --
(x == y
-- out --
error: Missing closing parenthesis
(x == y
       ^
## END

Parse error with unmatched closing parenthesis.

## BEGIN
-- in --
x == y)
-- out --
error: Unexpected token at end of expression
x == y)
      ^
## END

Parse error when parenthesis is empty.

## BEGIN
-- in --
()
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
()
 ^
## END

Parse error with invalid character after equality operator.

## BEGIN
-- in --
x == )
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
x == )
     ^
## END

Parse error with dot at the start.

## BEGIN
-- in --
.property
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
.property
^
## END

Parse error with multiple dots in sequence.

## BEGIN
-- in --
user..name
-- out --
error: Expected identifier after '.'
user..name
     ^
## END

Parse error with operator at the end.

## BEGIN
-- in --
x ==
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
x ==
    ^
## END

Parse error with not operator without operand.

## BEGIN
-- in --
!
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
!
 ^
## END

Parse error with trailing not operator.

## BEGIN
-- in --
x !
-- out --
error: Unexpected token at end of expression
x !
  ^
## END

Test empty array literal

## BEGIN
-- in --
[]
-- out --
ArrayLiteral { elements: [] }
## END

Test array literal with numbers

## BEGIN
-- in --
[1, 2, 3]
-- out --
ArrayLiteral { elements: [NumberLiteral { value: Number(1) }, NumberLiteral { value: Number(2) }, NumberLiteral { value: Number(3) }] }
## END

Test array literal with mixed types

## BEGIN
-- in --
[1, 'hello', true]
-- out --
ArrayLiteral { elements: [NumberLiteral { value: Number(1) }, StringLiteral { value: "hello" }, BooleanLiteral { value: true }] }
## END

Test nested array literals

## BEGIN
-- in --
[[1, 2], [3, 4]]
-- out --
ArrayLiteral { elements: [ArrayLiteral { elements: [NumberLiteral { value: Number(1) }, NumberLiteral { value: Number(2) }] }, ArrayLiteral { elements: [NumberLiteral { value: Number(3) }, NumberLiteral { value: Number(4) }] }] }
## END

Test array literal with variables

## BEGIN
-- in --
[x, user.name]
-- out --
ArrayLiteral { elements: [Variable { name: "x" }, PropertyAccess { object: Variable { name: "user" }, property: "name" }] }
## END

Empty object literal should parse successfully.

## BEGIN
-- in --
{}
-- out --
ObjectLiteral { properties: {} }
## END

Object literal with single property should parse successfully.

## BEGIN
-- in --
{name: 'John'}
-- out --
ObjectLiteral { properties: {"name": StringLiteral { value: "John" }} }
## END

Object literal with multiple properties should parse successfully.

## BEGIN
-- in --
{a: 'foo', b: 1}
-- out --
ObjectLiteral { properties: {"a": StringLiteral { value: "foo" }, "b": NumberLiteral { value: Number(1) }} }
## END

Object literal with complex expressions as values should parse successfully.

## BEGIN
-- in --
{user: user.name, active: !user.disabled}
-- out --
ObjectLiteral { properties: {"active": UnaryOp { operator: Not, operand: PropertyAccess { object: Variable { name: "user" }, property: "disabled" } }, "user": PropertyAccess { object: Variable { name: "user" }, property: "name" }} }
## END

Object literal with nested object should parse successfully.

## BEGIN
-- in --
{nested: {inner: 'value'}}
-- out --
ObjectLiteral { properties: {"nested": ObjectLiteral { properties: {"inner": StringLiteral { value: "value" }} }} }
## END

Array with trailing comma should parse successfully.

## BEGIN
-- in --
[
	1,
	2,
	3,
]
-- out --
ArrayLiteral { elements: [NumberLiteral { value: Number(1) }, NumberLiteral { value: Number(2) }, NumberLiteral { value: Number(3) }] }
## END

Array with trailing comma and single element should parse successfully.

## BEGIN
-- in --
[
	1,
]
-- out --
ArrayLiteral { elements: [NumberLiteral { value: Number(1) }] }
## END

Array with trailing comma and complex expressions should parse successfully.

## BEGIN
-- in --
[
	user.name,
	!user.disabled,
]
-- out --
ArrayLiteral { elements: [PropertyAccess { object: Variable { name: "user" }, property: "name" }, UnaryOp { operator: Not, operand: PropertyAccess { object: Variable { name: "user" }, property: "disabled" } }] }
## END

Object literal with trailing comma should parse successfully.

## BEGIN
-- in --
{
	a: 'foo',
	b: 1,
}
-- out --
ObjectLiteral { properties: {"a": StringLiteral { value: "foo" }, "b": NumberLiteral { value: Number(1) }} }
## END

Object literal with trailing comma and single property should parse successfully.

## BEGIN
-- in --
{
	name: 'John',
}
-- out --
ObjectLiteral { properties: {"name": StringLiteral { value: "John" }} }
## END

Object literal with trailing comma and complex expressions should parse successfully.

## BEGIN
-- in --
{
	user: user.name,
	active: !user.disabled,
}
-- out --
ObjectLiteral { properties: {"active": UnaryOp { operator: Not, operand: PropertyAccess { object: Variable { name: "user" }, property: "disabled" } }, "user": PropertyAccess { object: Variable { name: "user" }, property: "name" }} }
## END
