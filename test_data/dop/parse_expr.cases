## BEGIN
-- in --
a == b == c
-- out --
BinaryOp(BinaryOp(Variable("a"), Equal, Variable("b")), Equal, Variable("c"))
## END

## BEGIN
-- in --
user.name == admin.name
-- out --
BinaryOp(PropertyAccess(Variable("user"), "name"), Equal, PropertyAccess(Variable("admin"), "name"))
## END

## BEGIN
-- in --
app.user.profile.settings.theme
-- out --
PropertyAccess(PropertyAccess(PropertyAccess(PropertyAccess(Variable("app"), "user"), "profile"), "settings"), "theme")
## END

## BEGIN
-- in --
''
-- out --
StringLiteral("")
## END

## BEGIN
-- in --
42
-- out --
NumberLiteral(Number(42))
## END

## BEGIN
-- in --
3.14
-- out --
NumberLiteral(Number(3.14))
## END

## BEGIN
-- in --
user.profile.name
-- out --
PropertyAccess(PropertyAccess(Variable("user"), "profile"), "name")
## END

## BEGIN
-- in --
(x == y)
-- out --
BinaryOp(Variable("x"), Equal, Variable("y"))
## END

## BEGIN
-- in --
user.name
-- out --
PropertyAccess(Variable("user"), "name")
## END

## BEGIN
-- in --
'guest' == user.role
-- out --
BinaryOp(StringLiteral("guest"), Equal, PropertyAccess(Variable("user"), "role"))
## END

## BEGIN
-- in --
x == y
-- out --
BinaryOp(Variable("x"), Equal, Variable("y"))
## END

## BEGIN
-- in --
'hello'
-- out --
StringLiteral("hello")
## END

## BEGIN
-- in --
x
-- out --
Variable("x")
## END

## BEGIN
-- in --
'apple' == 'orange'
-- out --
BinaryOp(StringLiteral("apple"), Equal, StringLiteral("orange"))
## END

## BEGIN
-- in --
user.name == 'admin'
-- out --
BinaryOp(PropertyAccess(Variable("user"), "name"), Equal, StringLiteral("admin"))
## END

## BEGIN
-- in --
user.name == 'admin'
-- out --
BinaryOp(PropertyAccess(Variable("user"), "name"), Equal, StringLiteral("admin"))
## END

## BEGIN
-- in --
'hello world'
-- out --
StringLiteral("hello world")
## END

## BEGIN
-- in --
  user . name   ==   admin . name  
-- out --
BinaryOp(PropertyAccess(Variable("user"), "name"), Equal, PropertyAccess(Variable("admin"), "name"))
## END

Parse error when expression has trailing tokens.

## BEGIN
-- in --
x y
-- out --
error: Unexpected token at end of expression
x y
  ^
## END

Parse error when dot is not followed by identifier.

## BEGIN
-- in --
user.
-- out --
error: Expected identifier after '.'
user.
     ^
## END

Parse error when dot is followed by a number.

## BEGIN
-- in --
user.123
-- out --
error: Expected identifier after '.'
user.123
     ^^^
## END

Parse error when expression starts with an invalid token.

## BEGIN
-- in --
== x
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
== x
^^
## END

Parse error with unclosed parenthesis.

## BEGIN
-- in --
(x == y
-- out --
error: Missing closing parenthesis
(x == y
       ^
## END

Parse error with unmatched closing parenthesis.

## BEGIN
-- in --
x == y)
-- out --
error: Unexpected token at end of expression
x == y)
      ^
## END

Parse error when parenthesis is empty.

## BEGIN
-- in --
()
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
()
 ^
## END

Parse error with invalid character after equality operator.

## BEGIN
-- in --
x == )
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
x == )
     ^
## END

Parse error with dot at the start.

## BEGIN
-- in --
.property
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
.property
^
## END

Parse error with multiple dots in sequence.

## BEGIN
-- in --
user..name
-- out --
error: Expected identifier after '.'
user..name
     ^
## END

Parse error with operator at the end.

## BEGIN
-- in --
x ==
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
x ==
    ^
## END

Parse error with not operator without operand.

## BEGIN
-- in --
!
-- out --
error: Expected identifier, string literal, number literal, array literal, object literal, or opening parenthesis
!
 ^
## END

Parse error with trailing not operator.

## BEGIN
-- in --
x !
-- out --
error: Unexpected token at end of expression
x !
  ^
## END

Test empty array literal

## BEGIN
-- in --
[]
-- out --
ArrayLiteral([])
## END

Test array literal with numbers

## BEGIN
-- in --
[1, 2, 3]
-- out --
ArrayLiteral([NumberLiteral(Number(1)), NumberLiteral(Number(2)), NumberLiteral(Number(3))])
## END

Test array literal with mixed types

## BEGIN
-- in --
[1, 'hello', true]
-- out --
ArrayLiteral([NumberLiteral(Number(1)), StringLiteral("hello"), BooleanLiteral(true)])
## END

Test nested array literals

## BEGIN
-- in --
[[1, 2], [3, 4]]
-- out --
ArrayLiteral([ArrayLiteral([NumberLiteral(Number(1)), NumberLiteral(Number(2))]), ArrayLiteral([NumberLiteral(Number(3)), NumberLiteral(Number(4))])])
## END

Test array literal with variables

## BEGIN
-- in --
[x, user.name]
-- out --
ArrayLiteral([Variable("x"), PropertyAccess(Variable("user"), "name")])
## END

Empty object literal should parse successfully.

## BEGIN
-- in --
{}
-- out --
ObjectLiteral({})
## END

Object literal with single property should parse successfully.

## BEGIN
-- in --
{name: 'John'}
-- out --
ObjectLiteral({"name": StringLiteral("John")})
## END

Object literal with multiple properties should parse successfully.

## BEGIN
-- in --
{a: 'foo', b: 1}
-- out --
ObjectLiteral({"a": StringLiteral("foo"), "b": NumberLiteral(Number(1))})
## END

Object literal with complex expressions as values should parse successfully.

## BEGIN
-- in --
{user: user.name, active: !user.disabled}
-- out --
ObjectLiteral({"active": UnaryOp(Not, PropertyAccess(Variable("user"), "disabled")), "user": PropertyAccess(Variable("user"), "name")})
## END

Object literal with nested object should parse successfully.

## BEGIN
-- in --
{nested: {inner: 'value'}}
-- out --
ObjectLiteral({"nested": ObjectLiteral({"inner": StringLiteral("value")})})
## END

Array with trailing comma should parse successfully.

## BEGIN
-- in --
[
	1,
	2,
	3,
]
-- out --
ArrayLiteral([NumberLiteral(Number(1)), NumberLiteral(Number(2)), NumberLiteral(Number(3))])
## END

Array with trailing comma and single element should parse successfully.

## BEGIN
-- in --
[
	1,
]
-- out --
ArrayLiteral([NumberLiteral(Number(1))])
## END

Array with trailing comma and complex expressions should parse successfully.

## BEGIN
-- in --
[
	user.name,
	!user.disabled,
]
-- out --
ArrayLiteral([PropertyAccess(Variable("user"), "name"), UnaryOp(Not, PropertyAccess(Variable("user"), "disabled"))])
## END

Object literal with trailing comma should parse successfully.

## BEGIN
-- in --
{
	a: 'foo',
	b: 1,
}
-- out --
ObjectLiteral({"a": StringLiteral("foo"), "b": NumberLiteral(Number(1))})
## END

Object literal with trailing comma and single property should parse successfully.

## BEGIN
-- in --
{
	name: 'John',
}
-- out --
ObjectLiteral({"name": StringLiteral("John")})
## END

Object literal with trailing comma and complex expressions should parse successfully.

## BEGIN
-- in --
{
	user: user.name,
	active: !user.disabled,
}
-- out --
ObjectLiteral({"active": UnaryOp(Not, PropertyAccess(Variable("user"), "disabled")), "user": PropertyAccess(Variable("user"), "name")})
## END
