A basic type can be unified with itself.

## BEGIN
-- in --
(unify string string)
-- out --
## END

Two different basic types can not be unified.

## BEGIN
-- in --
(unify string bool)
-- out --
Can not unify types
## END

Two arrays can not be unified if their subtypes can not be unified.

## BEGIN
-- in --
(unify (array string) (array bool))
-- out --
Can not unify types
## END

An array can not be unified with a basic type.

## BEGIN
-- in --
(unify (array string) string)
-- out --
Can not unify types
## END

An object can not be unified with a basic type.

## BEGIN
-- in --
(unify (object foo string) string)
-- out --
Can not unify types
## END

Two objects can not be unified if they have corresponding properties that
can not be unified.

## BEGIN
-- in --
(unify (object foo string) (object foo bool))
-- out --
Can not unify types
## END

A type variable can be unified with a basic type.

## BEGIN
-- in --
(unify string t1)
(resolve t1)
-- out --
t1 : string
## END

The unifier works recursively and will unify subtypes of arrays that
contain type variables.

## BEGIN
-- in --
(unify (array bool) (array t1))
(resolve t1)
-- out --
t1 : boolean
## END

The unifier works recursively and will unify properties of objects that contain
type variables.

## BEGIN
-- in --
(unify t1 (array (object name string age (array bool))))
(unify t2 (array (object name t3 age t4 email string)))
(unify t1 t2)
(resolve t1)
(resolve t3)
(resolve t4)
-- out --
t1 : array[object[age: array[boolean], email: string, name: string]]
t3 : string
t4 : array[boolean]
## END

## BEGIN
-- in --
(unify (array (array (array string))) (array t1))
(unify t1 (array t2))
(resolve t2)
-- out --
t2 : array[string]
## END

## BEGIN
-- in --
(unify (object a string) t1)
(unify (object b bool) t1)
(unify (object c (array string)) t1)
(resolve t1)
-- out --
t1 : object[a: string, b: boolean, c: array[string]]
## END

## BEGIN
-- in --
(unify t1 (array t2))
(unify t2 (array t3))
(unify t3 (array t4))
(unify t4 (array bool))
(unify t5 t1)
(unify t6 t2)
(resolve t5)
(resolve t6)
(resolve t1)
-- out --
t5 : array[array[array[array[boolean]]]]
t6 : array[array[array[boolean]]]
t1 : array[array[array[array[boolean]]]]
## END

## BEGIN
-- in --
(unify t1 (object level1 (object level2 (object level3 (object level4 string)))))
(unify t2 (object level1 (object level2 (object level3 (object level4 t3) extra bool))))
(unify t1 t2)
(resolve t1)
(resolve t3)
-- out --
t1 : object[level1: object[level2: object[extra: boolean, level3: object[level4: string]]]]
t3 : string
## END

## BEGIN
-- in --
(unify (object) t1)
(resolve t1)
-- out --
t1 : object[]
## END

## BEGIN
-- in --
(unify t1 (object x string y bool))
(unify t2 (object x t3 z (array void)))
(unify t4 (object y t5 w string))
(unify t1 t2)
(unify t1 t4)
(resolve t1)
(resolve t2)
(resolve t4)
(resolve t3)
(resolve t5)
-- out --
t1 : object[w: string, x: string, y: boolean, z: array[void]]
t2 : object[w: string, x: string, y: boolean, z: array[void]]
t4 : object[w: string, x: string, y: boolean, z: array[void]]
t3 : string
t5 : boolean
## END

## BEGIN
-- in --
(unify (object foo string bar bool) (object foo t1 bar t2))
(resolve t1)
(resolve t2)
-- out --
t1 : string
t2 : boolean
## END

## BEGIN
-- in --
(unify t1 (array (array (object data (array (object id string value bool))))))
(unify t2 (array (array (object data t3))))
(unify t1 t2)
(resolve t1)
(resolve t3)
-- out --
t1 : array[array[object[data: array[object[id: string, value: boolean]]]]]
t3 : array[object[id: string, value: boolean]]
## END

## BEGIN
-- in --
(unify (array (array t1)) (array (array string)))
(resolve t1)
-- out --
t1 : string
## END

## BEGIN
-- in --
(unify t1 t2)
(unify (array t3) (array (array (array t1))))
(unify (array t3) (array (array (array (array string)))))
(resolve t2)
-- out --
t2 : array[string]
## END

## BEGIN
-- in --
(unify (object foo (object bar string)) (object foo t1))
(resolve t1)
-- out --
t1 : object[bar: string]
## END

## BEGIN
-- in --
(unify t1 (object a string b string c string))
(unify (object d string) t1)
(resolve t1)
-- out --
t1 : object[a: string, b: string, c: string, d: string]
## END

## BEGIN
-- in --
(unify t1 (object a string b string c (object a string b string)))
(unify (object d string) t1)
(resolve t1)
-- out --
t1 : object[a: string, b: string, c: object[a: string, b: string], d: string]
## END

## BEGIN
-- in --
(unify (object foo string) (object foo t1))
(resolve t1)
-- out --
t1 : string
## END

## BEGIN
-- in --
(unify (object foo string) t1)
(resolve t1)
(unify (object bar string) t1)
(resolve t1)
-- out --
t1 : object[foo: string]
t1 : object[bar: string, foo: string]
## END

## BEGIN
-- in --
(unify (object a string b bool) t1)
(unify (object c (array string) d void) t2)
(unify t1 t2)
(resolve t1)
(resolve t2)
-- out --
t1 : object[a: string, b: boolean, c: array[string], d: void]
t2 : object[a: string, b: boolean, c: array[string], d: void]
## END

## BEGIN
-- in --
(unify t1 (object foo t2))
(unify t2 string)
(resolve t1)
-- out --
t1 : object[foo: string]
## END

## BEGIN
-- in --
(unify (object a string) t1)
(unify (object b bool) t2)
(unify (object c void) t3)
(unify t1 t4)
(unify t2 t4)
(unify t3 t4)
(resolve t4)
(resolve t1)
(resolve t2)
(resolve t3)
-- out --
t4 : object[a: string, b: boolean, c: void]
t1 : object[a: string, b: boolean, c: void]
t2 : object[a: string, b: boolean, c: void]
t3 : object[a: string, b: boolean, c: void]
## END

## BEGIN
-- in --
(unify string string)
(unify t1 string)
(resolve t1)
-- out --
t1 : string
## END

## BEGIN
-- in --
(unify t1 t2)
(unify t2 t3)
(unify t3 t4)
(unify t5 t6)
(unify t6 t7)
(unify t7 t8)
(unify t8 string)
(unify t4 t5)
(resolve t1)
(resolve t8)
-- out --
t1 : string
t8 : string
## END

## BEGIN
-- in --
(unify t1 t2)
(unify t2 t3)
(unify t3 t4)
(unify t4 t5)
(unify t5 (array bool))
(resolve t1)
(resolve t3)
-- out --
t1 : array[boolean]
t3 : array[boolean]
## END

## BEGIN
-- in --
(unify t1 t1)
(resolve t1)
-- out --
t1 : any
## END

## BEGIN
-- in --
(unify (array t1) (array t1))
(resolve t1)
-- out --
t1 : any
## END

A type variable can be constrained to a basic type.

## BEGIN
-- in --
(constrain t1 string)
(resolve t1)
-- out --
t1 : string
## END

Multiple constraints accumulate properties in an object.

## BEGIN
-- in --
(constrain t1 (object foo string))
(constrain t1 (object bar string))
(resolve t1)
-- out --
t1 : object[bar: string, foo: string]
## END

Basic types cannot be constrained to different types.

## BEGIN
-- in --
(constrain string bool)
-- out --
Can not constrain types
## END

Array constraint with type variable element.

## BEGIN
-- in --
(constrain (array t1) (array string))
(resolve t1)
-- out --
t1 : string
## END

Conflicting property types in constraints should fail.

## BEGIN
-- in --
(constrain t1 (object name string))
(constrain t1 (object name number))
-- out --
Can not constrain types
## END

Nested object constraints.

## BEGIN
-- in --
(constrain t1 (object user (object name string)))
(constrain t1 (object user (object age number)))
(resolve t1)
-- out --
t1 : object[user: object[age: number, name: string]]
## END

Array of objects constraint.

## BEGIN
-- in --
(constrain t1 (array (object id number)))
(constrain t1 (array (object name string)))
(resolve t1)
-- out --
t1 : array[object[id: number, name: string]]
## END

Constraining already substituted type variable should work.

## BEGIN
-- in --
(constrain t1 string)
(constrain t1 string)
(resolve t1)
-- out --
t1 : string
## END

Constraining TypeVar(None) should work.

## BEGIN
-- in --
(unify t1 t1)
(constrain t1 string)
(resolve t1)
-- out --
t1 : string
## END

Deep nesting with multiple constraints.

## BEGIN
-- in --
(constrain t1 (object level1 (object level2 (object name string))))
(constrain t1 (object level1 (object level2 (object age number))))
(constrain t1 (object level1 (object active bool)))
(resolve t1)
-- out --
t1 : object[level1: object[active: boolean, level2: object[age: number, name: string]]]
## END

Arrays nested in objects.

## BEGIN
-- in --
(constrain t1 (object users (array (object role string))))
(constrain t1 (object users (array (object id number))))
(resolve t1)
-- out --
t1 : object[users: array[object[id: number, role: string]]]
## END

Mixed constraint types on same variable should fail when incompatible.

## BEGIN
-- in --
(constrain t1 string)
(constrain t1 (object foo string))
-- out --
Can not constrain types
## END

Constraining object property from type variable to concrete type.

## BEGIN
-- in --
(constrain t2 (object foo t1))
(constrain t2 (object foo string))
(resolve t2)
-- out --
t2 : object[foo: string]
## END

Multiple type variables in same constraint.

## BEGIN
-- in --
(constrain t3 (object foo t1 bar t2))
(constrain t3 (object foo string bar number))
(resolve t3)
-- out --
t3 : object[bar: number, foo: string]
## END

Constraining type variable to array with type variable element.

## BEGIN
-- in --
(constrain t1 (array t2))
(constrain t1 (array string))
(resolve t1)
-- out --
t1 : array[string]
## END

Chain of type variable constraints gets frozen at constraint time.

## BEGIN
-- in --
(constrain t1 (object user t2))
(constrain t2 (object name t3))
(constrain t3 string)
(resolve t1)
-- out --
t1 : object[user: any]
## END

Circular type variable references should work.

## BEGIN
-- in --
(constrain t1 (object next t1))
(constrain t1 (object value string))
(resolve t1)
-- out --
t1 : object[next: any, value: string]
## END

Multiple constraints on nested arrays.

## BEGIN
-- in --
(constrain t1 (array (array t2)))
(constrain t1 (array (array string)))
(resolve t1)
-- out --
t1 : array[array[string]]
## END

Constraint with conflicting nested types works due to frozen behavior.

## BEGIN
-- in --
(constrain t1 (object data (array t2)))
(constrain t2 string)
(constrain t1 (object data (array number)))
(resolve t1)
-- out --
t1 : object[data: array[number]]
## END

Mixed object and array constraints get frozen.

## BEGIN
-- in --
(constrain t1 (object items (array t2)))
(constrain t2 (object id t3 name string))
(constrain t3 number)
(resolve t1)
-- out --
t1 : object[items: array[any]]
## END
