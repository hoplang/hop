The typechecker allows empty files, and no types are emitted for them.

## BEGIN
-- main.hop --
-- out --
## END

The parameter type of a single component without any content is `void`.

## BEGIN
-- main.hop --
<main-comp>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

When an undefined component is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <render-name></render-name>!</h1>
</main-comp>
-- out --
Component render-name is not defined
## END

When a component references itself, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <main-comp></main-comp>!</h1>
</main-comp>
-- out --
Component main-comp is not defined
## END

When a component is defined twice, the typechecker outputs an error.

## BEGIN
-- main.hop --
<foo-comp>
</foo-comp>

<foo-comp>
</foo-comp>
-- out --
Component foo-comp is already defined
## END

When a component is defined with the same name as an imported component, the
typechecker outputs an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">

<foo-comp>
</foo-comp>

<bar-comp>
	<foo-comp/>
</bar-comp>
-- out --
Component foo-comp is already defined
## END

When a component is imported twice, the typechecker outputs an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">
<import component="foo-comp" from="other">

<main-comp>
	<foo-comp></foo-comp>
</main-comp>
-- out --
Component foo-comp is already defined
## END

When a component is imported from a module that doesn't exist the typechecker
outputs an error. TODO: Improve error message

## BEGIN
-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
Module other is not defined
## END

When a component that doesn't exist is imported from a module that does exist
the typechecker outputs an error.

## BEGIN
-- other.hop --
-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
Module other does not declare a component named foo-comp
## END

When a component is imported without being used the typechecker outputs
an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
Unused import: foo-comp
## END

The typechecker collects all errors rather than returning at the first error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <render-name></render-name>!</h1>
	<h1>Hello, <other-comp></other-comp>!</h1>
</main-comp>
-- out --
Component render-name is not defined
Component other-comp is not defined
## END

Defining a component with the same name in two different modules is allowed.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<foo-comp>
</foo-comp>
-- out --
other::foo-comp
	void
	[]
main::foo-comp
	void
	[]
## END

When a slot is defined twice in a component, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
    <slot-content>
        First definition
    </slot-content>
    <slot-content>
        Second definition
    </slot-content>
</main-comp>
-- out --
Slot 'content' is already defined
## END

Two components are allowed to have slots with the same name.

## BEGIN
-- main.hop --
<main-comp>
    <slot-content>
        First definition
    </slot-content>
</main-comp>
<foo-comp>
    <slot-content>
        First definition
    </slot-content>
</foo-comp>
-- out --
main::main-comp
	void
	["content"]
main::foo-comp
	void
	["content"]
## END

When an undefined slot is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</main-comp>

<bar-comp>
    <main-comp>
        <with-invalid>
            This slot doesn't exist
        </with-invalid>
    </main-comp>
</bar-comp>
-- out --
Slot 'invalid' is not defined in component main-comp
## END
## BEGIN
-- other.hop --
<foo-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</foo-comp>
-- main.hop --
<import component="foo-comp" from="other">

<bar-comp>
    <foo-comp>
        <with-invalid>
            This slot doesn't exist
        </with-invalid>
    </foo-comp>
</bar-comp>
-- out --
Slot 'invalid' is not defined in component foo-comp
## END

When slot-default is defined, it must be the only slot, otherwise the typechecker
outputs an error.

## BEGIN
-- main.hop --
<mixed-comp>
    <slot-default>Default slot</slot-default>
    <slot-other>Other slot</slot-other>
</mixed-comp>
-- out --
When using slot-default, it must be the only slot in the component
## END

When a variable shadows another variable, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {items}>
  <for {items in items.foo}>
  </for>
</main-comp>
-- out --
Variable items is already defined
## END
## BEGIN
-- main.hop --
<main-comp {items}>
  <for {items in items}>
  </for>
</main-comp>
-- out --
Variable items is already defined
## END
## BEGIN
-- main.hop --
<main-comp {items}>
  <for {item in items.a}>
    <for {item in items.b}>
      <div>{item}</div>
    </for>
  </for>
</main-comp>
-- out --
Variable item is already defined
## END

When an undefined variable is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {item in params}>
	  <if {item.active}>
	  </if>
	</for>
	<if {item.active}>
	</if>
</main-comp>
-- out --
Undefined variable: item
## END

When a variable is unused, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {items}>
  <for {item in items}>
      <div>{item}</div>
  </for>
  <for {item in items}>
  </for>
</main-comp>
-- out --
Unused variable item
## END
## BEGIN
-- main.hop --
<main-comp {items}>
  <for {item in items}>
  </for>
  <for {item in items}>
      <div>{item}</div>
  </for>
</main-comp>
-- out --
Unused variable item
## END
## BEGIN
-- main.hop --
<main-comp {items}>
  <for {item in items}>
  </for>
</main-comp>
-- out --
Unused variable item
## END
## BEGIN
-- main.hop --
<bar-comp {p}>
  <div>
  </div>
</bar-comp>
-- out --
Unused variable p
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {item in params}>
		<if {item.k}>
		</if>
	</for>
	<for {item in params}>
		<for {inner in item.k}>
			<div>{inner}</div>
		</for>
	</for>
</main-comp>
-- out --
Can not unify types
## END
## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params}>
	</if>
	<for {item in params}>
		<div>{item}</div>
	</for>
</main-comp>
-- out --
Can not unify types
## END

When successful, the typechecker identifies the parameter type of the component
as well as the defined slots.

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {item in params.items}>
		<if {item.active}>
		</if>
		<if {item.name}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	{items: {active: boolean, name: boolean}[]}
	[]
## END

A component should be able to define the <head> tag and define a slot for
the <title> tag.

## BEGIN
-- main.hop --
<custom-head>
	<head>
		<title><slot-title/></title>
	</head>
</custom-head>
-- out --
main::custom-head
	void
	["title"]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
  <if {(params.a == 'str') == params.b}>
    <div>Match</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{a: string, b: boolean}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.enabled}>
		<for {user in params.users}>
			<if {user.profile.verified}>
				<for {post in user.posts}>
					<if {post.published}>
					  published
					</if>
				</for>
			</if>
		</for>
	</if>
</main-comp>
-- out --
main::main-comp
	{enabled: boolean, users: {posts: {published: boolean}[], profile: {verified: boolean}}[]}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {section in params.sections}>
		<if {section.header.visible}>
			<for {item in section.items}>
				<if {item.data.valid}>
				</if>
			</for>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	{sections: {header: {visible: boolean}, items: {data: {valid: boolean}}[]}[]}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.i.j.k.l}>
	</if>
</main-comp>
-- out --
main::main-comp
	{i: {j: {k: {l: boolean}}}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.app.ui.theme.dark}>
	</if>
	<if {params.app.api.endpoints.users.enabled}>
	</if>
	<if {params.app.database.connection.ssl}>
	</if>
</main-comp>
-- out --
main::main-comp
	{app: {api: {endpoints: {users: {enabled: boolean}}}, database: {connection: {ssl: boolean}}, ui: {theme: {dark: boolean}}}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp entrypoint>
    <script>
        console.log("test");
    </script>
    <style>
        body { color: red; }
    </style>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data} entrypoint>
    <h1>Hello World</h1>
    <p>{data.message}</p>
</main-comp>
-- out --
main::main-comp
	{message: string}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
  <if {params.user.name == params.other_user.name}>
    <div>Same name</div>
  </if>
  <if {(params.data.x == params.data.y)}>
    <div>Parentheses work</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{data: {x: ?t21, y: ?t21}, other_user: {name: ?t8}, user: {name: ?t8}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
  <if {params.x == params.y}>
    <div>Values are equal</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{x: ?t3, y: ?t3}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {j in params.foo.bar}>
		<if {j}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	{foo: {bar: boolean[]}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {j in params}>
		<if {j.a}>
		</if>
	</for>
	<for {j in params}>
		<if {j.b}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	{a: boolean, b: boolean}[]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {i}>
	<for {j in i}>
		<for {k in j}>
			<if {k}>
			</if>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	boolean[][]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {i}>
	<for {j in i}>
		<if {j}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	boolean[]
	[]
## END

## BEGIN
-- utils.hop --
<button-comp {text}>
  <div>{text}</div>
</button-comp>

-- main.hop --
<import component="button-comp" from="utils">

<main-comp {label}>
  <button-comp {label}/>
</main-comp>

-- out --
utils::button-comp
	string
	[]
main::main-comp
	string
	[]
## END

## BEGIN
-- bar.hop --
<widget-comp {config}>
  <if {config.enabled}>
    <div>{config.title}</div>
  </if>
</widget-comp>

-- foo.hop --
<import component="widget-comp" from="bar">

<panel-comp {data}>
  <for {item in data.items}>
    <widget-comp {item}/>
  </for>
</panel-comp>

-- main.hop --
<import component="panel-comp" from="foo">

<main-comp {settings}>
  <panel-comp {settings.dashboard}/>
</main-comp>

-- out --
bar::widget-comp
	{enabled: boolean, title: string}
	[]
foo::panel-comp
	{items: {enabled: boolean, title: string}[]}
	[]
main::main-comp
	{dashboard: {items: {enabled: boolean, title: string}[]}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<div>{params}</div>
</main-comp>
-- out --
main::main-comp
	string
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.config.debug}>
	</if>
	<for {item in params.data}>
		<if {item.id}>
		</if>
		<for {attr in item.attributes}>
			<if {attr}>
			</if>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	{config: {debug: boolean}, data: {attributes: boolean[], id: boolean}[]}
	[]
## END

## BEGIN
-- main.hop --
<step3-comp {settings}>
	<if {settings.enabled}>
	</if>
</step3-comp>

<step2-comp {config}>
	<step3-comp {config.settings}/>
</step2-comp>

<step1-comp {data}>
	<step2-comp {data.config}/>
</step1-comp>

<main-comp {params}>
	<step1-comp {params}/>
</main-comp>
-- out --
main::step3-comp
	{enabled: boolean}
	[]
main::step2-comp
	{settings: {enabled: boolean}}
	[]
main::step1-comp
	{config: {settings: {enabled: boolean}}}
	[]
main::main-comp
	{config: {settings: {enabled: boolean}}}
	[]
## END

## BEGIN
-- main.hop --
<main-card {item}>
  <div>{item.title}
  </div>
  <if {item.active}>
    <span>{item.status}
    </span>
  </if>
</main-card>

<main-list {items}>
  <for {item in items}>
    <main-card {item}/>
  </for>
</main-list>

<main-comp {data}>
  <main-list {data.items}/>
</main-comp>
-- out --
main::main-card
	{active: boolean, status: string, title: string}
	[]
main::main-list
	{active: boolean, status: string, title: string}[]
	[]
main::main-comp
	{items: {active: boolean, status: string, title: string}[]}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.i.j.k.l}>
		<if {params.i.k}>
		</if>
	</if>
</main-comp>
-- out --
main::main-comp
	{i: {j: {k: {l: boolean}}, k: boolean}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<if {params.i.j.k.l}>
	</if>
	<if {params.i.k}>
	</if>
</main-comp>
-- out --
main::main-comp
	{i: {j: {k: {l: boolean}}, k: boolean}}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {tag in params.tags}>
		<if {tag}>
		</if>
	</for>
	<for {category in params.categories}>
		<if {category}>
		</if>
	</for>
	<if {params.metadata.title}>
	</if>
</main-comp>
-- out --
main::main-comp
	{categories: boolean[], metadata: {title: boolean}, tags: boolean[]}
	[]
## END

## BEGIN
-- main.hop --
<main-bar {p}>
  <if {p}>
  </if>
</main-bar>

<main-foo {p}>
  <main-bar {p}/>
</main-foo>

<main-comp {i}>
  <main-foo {i}/>
</main-comp>
-- out --
main::main-bar
	boolean
	[]
main::main-foo
	boolean
	[]
main::main-comp
	boolean
	[]
## END

## BEGIN
-- main.hop --
<execute-step {step}>
	<if {step.condition}>
	</if>
</execute-step>

<execute-workflow {workflow}>
	<if {workflow.enabled}>
		<for {step in workflow.steps}>
			<execute-step {step}/>
		</for>
	</if>
</execute-workflow>

<main-comp {params}>
	<for {workflow in params.workflows}>
		<execute-workflow {workflow}/>
	</for>
</main-comp>
-- out --
main::execute-step
	{condition: boolean}
	[]
main::execute-workflow
	{enabled: boolean, steps: {condition: boolean}[]}
	[]
main::main-comp
	{workflows: {enabled: boolean, steps: {condition: boolean}[]}[]}
	[]
## END

## BEGIN
-- main.hop --
<foo-comp {p}>
  <if {p}>
  </if>
</foo-comp>

<main-comp {i}>
  <foo-comp {i}/>
</main-comp>
-- out --
main::foo-comp
	boolean
	[]
main::main-comp
	boolean
	[]
## END

## BEGIN
-- main.hop --
<process-item {item}>
	<if {item.status.active}>
	</if>
	<for {child in item.children}>
		<if {child.visible}>
		</if>
	</for>
</process-item>

<main-comp {params}>
	<for {item in params.items}>
		<process-item {item}/>
	</for>
</main-comp>
-- out --
main::process-item
	{children: {visible: boolean}[], status: {active: boolean}}
	[]
main::main-comp
	{items: {children: {visible: boolean}[], status: {active: boolean}}[]}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {user}>
  <a set-href="user.url" set-class="user.theme">Link</a>
</main-comp>
-- out --
main::main-comp
	{theme: string, url: string}
	[]
## END

## BEGIN
-- main.hop --
<main-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</main-comp>

<bar-comp>
    <main-comp>
        <with-data>
            Here's the content for the 'data' slot
        </with-data>
    </main-comp>
</bar-comp>
-- out --
main::main-comp
	void
	["data"]
main::bar-comp
	void
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data}>
  <div>{data.message}
  </div>
</main-comp>
-- out --
main::main-comp
	{message: string}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
  <if {params.role == 'admin'}>
    <div>Admin</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{role: string}
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params}>
	<for {level1 in params}>
		<for {level2 in level1}>
			<for {level3 in level2}>
				<if {level3}>
				</if>
			</for>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	boolean[][][]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data}>
	<hop-x-raw>foo bar</hop-x-raw>
	<div>{data.message}</div>
</main-comp>
-- out --
main::main-comp
	{message: string}
	[]
## END

## BEGIN
-- main.hop --
<main-comp>
	<hop-x-raw>
		<div>some html</div>
		<p>more content</p>
	</hop-x-raw>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

## BEGIN
-- main.hop --
<main-comp>
	<hop-x-raw>
		<undefined-component {nonexistent.field}>
			<another-undefined {also.nonexistent} />
		</undefined-component>
	</hop-x-raw>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test <if> tag with boolean expression.

## BEGIN
-- main.hop --
<main-comp {user}>
  <if {user.isActive}>
    <div>User is active</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{isActive: boolean}
	[]
## END

Test <if> tag with comparison expression.

## BEGIN
-- main.hop --
<main-comp {data}>
  <if {data.status == 'approved'}>
    <div>Status is approved</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{status: string}
	[]
## END

Test <if> tag with nested conditionals.

## BEGIN
-- main.hop --
<main-comp {config}>
  <if {config.enabled}>
    <div>Feature enabled</div>
    <if {config.debug}>
      <div>Debug mode on</div>
    </if>
  </if>
</main-comp>
-- out --
main::main-comp
	{debug: boolean, enabled: boolean}
	[]
## END

Test HOP_MODE global variable is available and has string type.

## BEGIN
-- main.hop --
<main-comp>
  <div>{HOP_MODE}</div>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test HOP_MODE can be used in conditions.

## BEGIN
-- main.hop --
<main-comp>
  <if {HOP_MODE == 'dev'}>
    <div>Development mode</div>
  </if>
  <if {HOP_MODE == 'build'}>
    <div>Build mode</div>
  </if>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test type inference works when comparing variables to HOP_MODE.

## BEGIN
-- main.hop --
<main-comp {params}>
  <if {params.mode == HOP_MODE}>
    <div>Mode matches</div>
  </if>
</main-comp>
-- out --
main::main-comp
	{mode: string}
	[]
## END
