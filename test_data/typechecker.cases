The typechecker allows empty files, and no types are emitted for them.

## BEGIN
-- main.hop --
-- out --
## END

The parameter type of a single component without any content is `void`.

## BEGIN
-- main.hop --
<main-comp>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

When an undefined component is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <render-name></render-name>!</h1>
</main-comp>
-- out --
error: Component render-name is not defined
  --> main.hop (line 2, col 13)
1 | <main-comp>
2 |     <h1>Hello, <render-name></render-name>!</h1>
  |                ^^^^^^^^^^^^^
## END

When a component references itself, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <main-comp></main-comp>!</h1>
</main-comp>
-- out --
error: Component main-comp is not defined
  --> main.hop (line 2, col 13)
1 | <main-comp>
2 |     <h1>Hello, <main-comp></main-comp>!</h1>
  |                ^^^^^^^^^^^
## END

When a component is defined twice, the typechecker outputs an error.

## BEGIN
-- main.hop --
<foo-comp>
</foo-comp>

<foo-comp>
</foo-comp>
-- out --
error: Component foo-comp is already defined
  --> main.hop (line 4, col 1)
3 | 
4 | <foo-comp>
  | ^^^^^^^^^^
## END

When a component is defined with the same name as an imported component, the
typechecker outputs an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">

<foo-comp>
</foo-comp>

<bar-comp>
	<foo-comp/>
</bar-comp>
-- out --
error: Component foo-comp is already defined
  --> main.hop (line 3, col 1)
2 | 
3 | <foo-comp>
  | ^^^^^^^^^^
## END

When a component is imported twice, the typechecker outputs an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">
<import component="foo-comp" from="other">

<main-comp>
	<foo-comp></foo-comp>
</main-comp>
-- out --
error: Component foo-comp is already defined
  --> main.hop (line 2, col 1)
1 | <import component="foo-comp" from="other">
2 | <import component="foo-comp" from="other">
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
## END

When a component is imported from a module that doesn't exist the typechecker
outputs an error. TODO: Improve error message

## BEGIN
-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
error: Module other is not defined
  --> main.hop (line 1, col 1)
1 | <import component="foo-comp" from="other">
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
## END

When a component that doesn't exist is imported from a module that does exist
the typechecker outputs an error.

## BEGIN
-- other.hop --
-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
error: Module other does not declare a component named foo-comp
  --> main.hop (line 1, col 1)
1 | <import component="foo-comp" from="other">
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
## END

When a component is imported without being used the typechecker outputs
an error.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<import component="foo-comp" from="other">

<main-comp>
</main-comp>
-- out --
error: Unused import: foo-comp
  --> main.hop (line 1, col 1)
1 | <import component="foo-comp" from="other">
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
## END

The typechecker collects all errors rather than returning at the first error.

## BEGIN
-- main.hop --
<main-comp>
	<h1>Hello, <render-name></render-name>!</h1>
	<h1>Hello, <other-comp></other-comp>!</h1>
</main-comp>
-- out --
error: Component render-name is not defined
  --> main.hop (line 2, col 13)
1 | <main-comp>
2 |     <h1>Hello, <render-name></render-name>!</h1>
  |                ^^^^^^^^^^^^^

error: Component other-comp is not defined
  --> main.hop (line 3, col 13)
2 |     <h1>Hello, <render-name></render-name>!</h1>
3 |     <h1>Hello, <other-comp></other-comp>!</h1>
  |                ^^^^^^^^^^^^
## END

Defining a component with the same name in two different modules is allowed.

## BEGIN
-- other.hop --
<foo-comp>
</foo-comp>

-- main.hop --
<foo-comp>
</foo-comp>
-- out --
other::foo-comp
	void
	[]
main::foo-comp
	void
	[]
## END

When a slot is defined twice in a component, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
    <slot-content>
        First definition
    </slot-content>
    <slot-content>
        Second definition
    </slot-content>
</main-comp>
-- out --
error: Slot 'content' is already defined
  --> main.hop (line 5, col 5)
4 |     </slot-content>
5 |     <slot-content>
  |     ^^^^^^^^^^^^^^
## END

Two components are allowed to have slots with the same name.

## BEGIN
-- main.hop --
<main-comp>
    <slot-content>
        First definition
    </slot-content>
</main-comp>
<foo-comp>
    <slot-content>
        First definition
    </slot-content>
</foo-comp>
-- out --
main::main-comp
	void
	["content"]
main::foo-comp
	void
	["content"]
## END

When an undefined slot is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</main-comp>

<bar-comp>
    <main-comp>
        <with-invalid>
            This slot doesn't exist
        </with-invalid>
    </main-comp>
</bar-comp>
-- out --
error: Slot 'invalid' is not defined in component main-comp
  --> main.hop (line 9, col 9)
 8 |     <main-comp>
 9 |         <with-invalid>
   |         ^^^^^^^^^^^^^^
## END
## BEGIN
-- other.hop --
<foo-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</foo-comp>
-- main.hop --
<import component="foo-comp" from="other">

<bar-comp>
    <foo-comp>
        <with-invalid>
            This slot doesn't exist
        </with-invalid>
    </foo-comp>
</bar-comp>
-- out --
error: Slot 'invalid' is not defined in component foo-comp
  --> main.hop (line 5, col 9)
4 |     <foo-comp>
5 |         <with-invalid>
  |         ^^^^^^^^^^^^^^
## END

When slot-default is defined, it must be the only slot, otherwise the typechecker
outputs an error.

## BEGIN
-- main.hop --
<mixed-comp>
    <slot-default>Default slot</slot-default>
    <slot-other>Other slot</slot-other>
</mixed-comp>
-- out --
error: When using slot-default, it must be the only slot in the component
  --> main.hop (line 3, col 5)
2 |     <slot-default>Default slot</slot-default>
3 |     <slot-other>Other slot</slot-other>
  |     ^^^^^^^^^^^^
## END

When a variable shadows another variable, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {items: object[foo: array[string]]}>
  <for {items in items.foo}>
  </for>
</main-comp>
-- out --
error: Variable items is already defined
  --> main.hop (line 2, col 9)
1 | <main-comp {items: object[foo: array[string]]}>
2 |   <for {items in items.foo}>
  |         ^^^^^
## END
## BEGIN
-- main.hop --
<main-comp {items: array[string]}>
  <for {items in items}>
  </for>
</main-comp>
-- out --
error: Variable items is already defined
  --> main.hop (line 2, col 9)
1 | <main-comp {items: array[string]}>
2 |   <for {items in items}>
  |         ^^^^^
## END
## BEGIN
-- main.hop --
<main-comp {items: object[a: array[string], b: array[string]]}>
  <for {item in items.a}>
    <for {item in items.b}>
      <div>{item}</div>
    </for>
  </for>
</main-comp>
-- out --
error: Variable item is already defined
  --> main.hop (line 3, col 11)
2 |   <for {item in items.a}>
3 |     <for {item in items.b}>
  |           ^^^^
## END

When an undefined variable is referenced, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {params: array[object[active: boolean]]}>
	<for {item in params}>
	  <if {item.active}>
	  </if>
	</for>
	<if {item.active}>
	</if>
</main-comp>
-- out --
error: Undefined variable: item
  --> main.hop (line 6, col 7)
5 |     </for>
6 |     <if {item.active}>
  |          ^^^^^^^^^^^
## END

When a variable is unused, the typechecker outputs an error.

## BEGIN
-- main.hop --
<main-comp {items: array[string]}>
  <for {item in items}>
      <div>{item}</div>
  </for>
  <for {item in items}>
  </for>
</main-comp>
-- out --
error: Unused variable item
  --> main.hop (line 5, col 9)
4 |   </for>
5 |   <for {item in items}>
  |         ^^^^
## END
## BEGIN
-- main.hop --
<main-comp {items: array[string]}>
  <for {item in items}>
  </for>
  <for {item in items}>
      <div>{item}</div>
  </for>
</main-comp>
-- out --
error: Unused variable item
  --> main.hop (line 2, col 9)
1 | <main-comp {items: array[string]}>
2 |   <for {item in items}>
  |         ^^^^
## END
## BEGIN
-- main.hop --
<main-comp {items: array[string]}>
  <for {item in items}>
  </for>
</main-comp>
-- out --
error: Unused variable item
  --> main.hop (line 2, col 9)
1 | <main-comp {items: array[string]}>
2 |   <for {item in items}>
  |         ^^^^
## END
## BEGIN
-- main.hop --
<bar-comp {p: string}>
  <div>
  </div>
</bar-comp>
-- out --
error: Unused variable p
  --> main.hop (line 1, col 12)
1 | <bar-comp {p: string}>
  |            ^^^^^^^^^
## END

## BEGIN
-- main.hop --
<main-comp {params: array[object[k: boolean]]}>
	<for {item in params}>
		<if {item.k}>
		</if>
	</for>
	<for {item in params}>
		<for {inner in item.k}>
			<div>{inner}</div>
		</for>
	</for>
</main-comp>
-- out --
error: Can not iterate over boolean
  --> main.hop (line 7, col 18)
 6 |     <for {item in params}>
 7 |         <for {inner in item.k}>
   |                        ^^^^^^
## END
## BEGIN
-- main.hop --
<main-comp {params: boolean}>
	<if {params}>
	</if>
	<for {item in params}>
		<div>{item}</div>
	</for>
</main-comp>
-- out --
error: Can not iterate over boolean
  --> main.hop (line 4, col 16)
3 |     </if>
4 |     <for {item in params}>
  |                   ^^^^^^
## END

When successful, the typechecker identifies the parameter type of the component
as well as the defined slots.

## BEGIN
-- main.hop --
<main-comp {params: object[items: array[object[active: boolean, name: boolean]]]}>
	<for {item in params.items}>
		<if {item.active}>
		</if>
		<if {item.name}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	object[items: array[object[active: boolean, name: boolean]]]
	[]
## END

A component should be able to define the <head> tag and define a slot for
the <title> tag.

## BEGIN
-- main.hop --
<custom-head>
	<head>
		<title><slot-title/></title>
	</head>
</custom-head>
-- out --
main::custom-head
	void
	["title"]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[a: string, b: boolean]}>
  <if {(params.a == 'str') == params.b}>
    <div>Match</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[a: string, b: boolean]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[enabled: boolean, users: array[object[profile: object[verified: boolean], posts: array[object[published: boolean]]]]]}>
	<if {params.enabled}>
		<for {user in params.users}>
			<if {user.profile.verified}>
				<for {post in user.posts}>
					<if {post.published}>
					  published
					</if>
				</for>
			</if>
		</for>
	</if>
</main-comp>
-- out --
main::main-comp
	object[enabled: boolean, users: array[object[posts: array[object[published: boolean]], profile: object[verified: boolean]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[sections: array[object[header: object[visible: boolean], items: array[object[data: object[valid: boolean]]]]]]}>
	<for {section in params.sections}>
		<if {section.header.visible}>
			<for {item in section.items}>
				<if {item.data.valid}>
				</if>
			</for>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	object[sections: array[object[header: object[visible: boolean], items: array[object[data: object[valid: boolean]]]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[i: object[j: object[k: object[l: boolean]]]]}>
	<if {params.i.j.k.l}>
	</if>
</main-comp>
-- out --
main::main-comp
	object[i: object[j: object[k: object[l: boolean]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[app: object[ui: object[theme: object[dark: boolean]], api: object[endpoints: object[users: object[enabled: boolean]]], database: object[connection: object[ssl: boolean]]]]}>
	<if {params.app.ui.theme.dark}>
	</if>
	<if {params.app.api.endpoints.users.enabled}>
	</if>
	<if {params.app.database.connection.ssl}>
	</if>
</main-comp>
-- out --
main::main-comp
	object[app: object[api: object[endpoints: object[users: object[enabled: boolean]]], database: object[connection: object[ssl: boolean]], ui: object[theme: object[dark: boolean]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp entrypoint>
    <script>
        console.log("test");
    </script>
    <style>
        body { color: red; }
    </style>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data: object[message: string]} entrypoint>
    <h1>Hello World</h1>
    <p>{data.message}</p>
</main-comp>
-- out --
main::main-comp
	object[message: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[user: object[name: string], other_user: object[name: string], data: object[x: string, y: string]]}>
  <if {params.user.name == params.other_user.name}>
    <div>Same name</div>
  </if>
  <if {(params.data.x == params.data.y)}>
    <div>Parentheses work</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[data: object[x: string, y: string], other_user: object[name: string], user: object[name: string]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[x: string, y: string]}>
  <if {params.x == params.y}>
    <div>Values are equal</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[x: string, y: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[foo: object[bar: array[boolean]]]}>
	<for {j in params.foo.bar}>
		<if {j}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	object[foo: object[bar: array[boolean]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: array[object[a: boolean, b: boolean]]}>
	<for {j in params}>
		<if {j.a}>
		</if>
	</for>
	<for {j in params}>
		<if {j.b}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	array[object[a: boolean, b: boolean]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {i: array[array[boolean]]}>
	<for {j in i}>
		<for {k in j}>
			<if {k}>
			</if>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	array[array[boolean]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {i: array[boolean]}>
	<for {j in i}>
		<if {j}>
		</if>
	</for>
</main-comp>
-- out --
main::main-comp
	array[boolean]
	[]
## END

## BEGIN
-- utils.hop --
<button-comp {text: string}>
  <div>{text}</div>
</button-comp>

-- main.hop --
<import component="button-comp" from="utils">

<main-comp {label: string}>
  <button-comp {label}/>
</main-comp>

-- out --
utils::button-comp
	string
	[]
main::main-comp
	string
	[]
## END

## BEGIN
-- bar.hop --
<widget-comp {config: object[enabled: boolean, title: string]}>
  <if {config.enabled}>
    <div>{config.title}</div>
  </if>
</widget-comp>

-- foo.hop --
<import component="widget-comp" from="bar">

<panel-comp {data: object[items: array[object[enabled: boolean, title: string]]]}>
  <for {item in data.items}>
    <widget-comp {item}/>
  </for>
</panel-comp>

-- main.hop --
<import component="panel-comp" from="foo">

<main-comp {settings: object[dashboard: object[items: array[object[enabled: boolean, title: string]]]]}>
  <panel-comp {settings.dashboard}/>
</main-comp>

-- out --
bar::widget-comp
	object[enabled: boolean, title: string]
	[]
foo::panel-comp
	object[items: array[object[enabled: boolean, title: string]]]
	[]
main::main-comp
	object[dashboard: object[items: array[object[enabled: boolean, title: string]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: string}>
	<div>{params}</div>
</main-comp>
-- out --
main::main-comp
	string
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[config: object[debug: boolean], data: array[object[id: boolean, attributes: array[boolean]]]]}>
	<if {params.config.debug}>
	</if>
	<for {item in params.data}>
		<if {item.id}>
		</if>
		<for {attr in item.attributes}>
			<if {attr}>
			</if>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	object[config: object[debug: boolean], data: array[object[attributes: array[boolean], id: boolean]]]
	[]
## END

## BEGIN
-- main.hop --
<step3-comp {settings: object[enabled: boolean]}>
	<if {settings.enabled}>
	</if>
</step3-comp>

<step2-comp {config: object[settings: object[enabled: boolean]]}>
	<step3-comp {config.settings}/>
</step2-comp>

<step1-comp {data: object[config: object[settings: object[enabled: boolean]]]}>
	<step2-comp {data.config}/>
</step1-comp>

<main-comp {params: object[config: object[settings: object[enabled: boolean]]]}>
	<step1-comp {params}/>
</main-comp>
-- out --
main::step3-comp
	object[enabled: boolean]
	[]
main::step2-comp
	object[settings: object[enabled: boolean]]
	[]
main::step1-comp
	object[config: object[settings: object[enabled: boolean]]]
	[]
main::main-comp
	object[config: object[settings: object[enabled: boolean]]]
	[]
## END

## BEGIN
-- main.hop --
<main-card {item: object[title: string, active: boolean, status: string]}>
  <div>{item.title}
  </div>
  <if {item.active}>
    <span>{item.status}
    </span>
  </if>
</main-card>

<main-list {items: array[object[title: string, active: boolean, status: string]]}>
  <for {item in items}>
    <main-card {item}/>
  </for>
</main-list>

<main-comp {data: object[items: array[object[title: string, active: boolean, status: string]]]}>
  <main-list {data.items}/>
</main-comp>
-- out --
main::main-card
	object[active: boolean, status: string, title: string]
	[]
main::main-list
	array[object[active: boolean, status: string, title: string]]
	[]
main::main-comp
	object[items: array[object[active: boolean, status: string, title: string]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[i: object[j: object[k: object[l: boolean]], k: boolean]]}>
	<if {params.i.j.k.l}>
		<if {params.i.k}>
		</if>
	</if>
</main-comp>
-- out --
main::main-comp
	object[i: object[j: object[k: object[l: boolean]], k: boolean]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[i: object[j: object[k: object[l: boolean]], k: boolean]]}>
	<if {params.i.j.k.l}>
	</if>
	<if {params.i.k}>
	</if>
</main-comp>
-- out --
main::main-comp
	object[i: object[j: object[k: object[l: boolean]], k: boolean]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[tags: array[boolean], categories: array[boolean], metadata: object[title: boolean]]}>
	<for {tag in params.tags}>
		<if {tag}>
		</if>
	</for>
	<for {category in params.categories}>
		<if {category}>
		</if>
	</for>
	<if {params.metadata.title}>
	</if>
</main-comp>
-- out --
main::main-comp
	object[categories: array[boolean], metadata: object[title: boolean], tags: array[boolean]]
	[]
## END

## BEGIN
-- main.hop --
<main-bar {p: boolean}>
  <if {p}>
  </if>
</main-bar>

<main-foo {p: boolean}>
  <main-bar {p}/>
</main-foo>

<main-comp {i: boolean}>
  <main-foo {i}/>
</main-comp>
-- out --
main::main-bar
	boolean
	[]
main::main-foo
	boolean
	[]
main::main-comp
	boolean
	[]
## END

## BEGIN
-- main.hop --
<execute-step {step: object[condition: boolean]}>
	<if {step.condition}>
	</if>
</execute-step>

<execute-workflow {workflow: object[enabled: boolean, steps: array[object[condition: boolean]]]}>
	<if {workflow.enabled}>
		<for {step in workflow.steps}>
			<execute-step {step}/>
		</for>
	</if>
</execute-workflow>

<main-comp {params: object[workflows: array[object[enabled: boolean, steps: array[object[condition: boolean]]]]]}>
	<for {workflow in params.workflows}>
		<execute-workflow {workflow}/>
	</for>
</main-comp>
-- out --
main::execute-step
	object[condition: boolean]
	[]
main::execute-workflow
	object[enabled: boolean, steps: array[object[condition: boolean]]]
	[]
main::main-comp
	object[workflows: array[object[enabled: boolean, steps: array[object[condition: boolean]]]]]
	[]
## END

## BEGIN
-- main.hop --
<foo-comp {p: boolean}>
  <if {p}>
  </if>
</foo-comp>

<main-comp {i: boolean}>
  <foo-comp {i}/>
</main-comp>
-- out --
main::foo-comp
	boolean
	[]
main::main-comp
	boolean
	[]
## END

## BEGIN
-- main.hop --
<process-item {item: object[children: array[object[visible: boolean]], status: object[active: boolean]]}>
	<if {item.status.active}>
	</if>
	<for {child in item.children}>
		<if {child.visible}>
		</if>
	</for>
</process-item>

<main-comp {params: object[items: array[object[children: array[object[visible: boolean]], status: object[active: boolean]]]]}>
	<for {item in params.items}>
		<process-item {item}/>
	</for>
</main-comp>
-- out --
main::process-item
	object[children: array[object[visible: boolean]], status: object[active: boolean]]
	[]
main::main-comp
	object[items: array[object[children: array[object[visible: boolean]], status: object[active: boolean]]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {user: object[url: string, theme: string]}>
  <a set-href="user.url" set-class="user.theme">Link</a>
</main-comp>
-- out --
main::main-comp
	object[theme: string, url: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp>
    <strong>
        <slot-data></slot-data>
    </strong>
</main-comp>

<bar-comp>
    <main-comp>
        <with-data>
            Here's the content for the 'data' slot
        </with-data>
    </main-comp>
</bar-comp>
-- out --
main::main-comp
	void
	["data"]
main::bar-comp
	void
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data: object[message: string]}>
  <div>{data.message}
  </div>
</main-comp>
-- out --
main::main-comp
	object[message: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[role: string]}>
  <if {params.role == 'admin'}>
    <div>Admin</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[role: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: array[array[array[boolean]]]}>
	<for {level1 in params}>
		<for {level2 in level1}>
			<for {level3 in level2}>
				<if {level3}>
				</if>
			</for>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	array[array[array[boolean]]]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: array[string]}>
	<for {x in params}>
		{x}
	</for>
	<for {y in params.foo}>
		{y}
	</for>
</main-comp>
-- out --
error: array[string] can not be used as an object
  --> main.hop (line 5, col 13)
4 |     </for>
5 |     <for {y in params.foo}>
  |                ^^^^^^^^^^
## END

## BEGIN
-- main.hop --
<main-comp {data: object[message: string]}>
	<hop-x-raw>foo bar</hop-x-raw>
	<div>{data.message}</div>
</main-comp>
-- out --
main::main-comp
	object[message: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp>
	<hop-x-raw>
		<div>some html</div>
		<p>more content</p>
	</hop-x-raw>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Content inside <hop-x-raw> tags are not parsed nor typechecked.

## BEGIN
-- main.hop --
<main-comp>
	<hop-x-raw>
		<undefined-component {nonexistent.field}>
			<another-undefined {also.nonexistent} />
		</undefined-component>
	</hop-x-raw>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test <if> tag with boolean expression.

## BEGIN
-- main.hop --
<main-comp {user: object[isActive: boolean]}>
  <if {user.isActive}>
    <div>User is active</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[isActive: boolean]
	[]
## END

Test <if> tag with comparison expression.

## BEGIN
-- main.hop --
<main-comp {data: object[status: string]}>
  <if {data.status == 'approved'}>
    <div>Status is approved</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[status: string]
	[]
## END

Comparison only works when the types of each operand are equal.

## BEGIN
-- main.hop --
<main-comp>
  <if {1 == 'approved'}>
    <div>Status is approved</div>
  </if>
</main-comp>
-- out --
error: Can not compare number to string
  --> main.hop (line 2, col 8)
1 | <main-comp>
2 |   <if {1 == 'approved'}>
  |        ^^^^^^^^^^^^^^^
## END

Test <if> tag with nested conditionals.

## BEGIN
-- main.hop --
<main-comp {config: object[enabled: boolean, debug: boolean]}>
  <if {config.enabled}>
    <div>Feature enabled</div>
    <if {config.debug}>
      <div>Debug mode on</div>
    </if>
  </if>
</main-comp>
-- out --
main::main-comp
	object[debug: boolean, enabled: boolean]
	[]
## END


## BEGIN
-- main.hop --
<main-comp {config: object[debug: boolean]}>
  <if {config.debug}>
    <div>Debug mode on</div>
  </if>
</main-comp>
<foo-comp>
  <main-comp {1}/>
</foo-comp>
-- out --
error: Argument of type number is incompatible with expected type object[debug: boolean]
  --> main.hop (line 7, col 15)
6 | <foo-comp>
7 |   <main-comp {1}/>
  |               ^
## END

Test HOP_MODE global variable is available and has string type.

## BEGIN
-- main.hop --
<main-comp>
  <div>{HOP_MODE}</div>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test HOP_MODE can be used in conditions.

## BEGIN
-- main.hop --
<main-comp>
  <if {HOP_MODE == 'dev'}>
    <div>Development mode</div>
  </if>
  <if {HOP_MODE == 'build'}>
    <div>Build mode</div>
  </if>
</main-comp>
-- out --
main::main-comp
	void
	[]
## END

Test type inference works when comparing variables to HOP_MODE.

## BEGIN
-- main.hop --
<main-comp {params: object[mode: string]}>
  <if {params.mode == HOP_MODE}>
    <div>Mode matches</div>
  </if>
</main-comp>
-- out --
main::main-comp
	object[mode: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {params: object[foo: string]}>
  <if {params.foo == 'foo'}>
    eq 1
  </if>
  <if {params == params}>
    eq 2
  </if>
</main-comp>
-- out --
main::main-comp
	object[foo: string]
	[]
## END

## BEGIN
-- main.hop --
<main-comp {data: array[object[title: string, items: array[string]]]}>
	<for {section in data}>
		<h1>{section.title}</h1>
		<for {item in section.items}>
			<div>{item}</div>
		</for>
	</for>
</main-comp>
-- out --
main::main-comp
	array[object[items: array[string], title: string]]
	[]
## END

## BEGIN
-- main.hop --
<string-comp {message: string}>
	<div>{message}</div>
</string-comp>
<main-comp>
	<string-comp {42}/>
</main-comp>
-- out --
error: Argument of type number is incompatible with expected type string
  --> main.hop (line 5, col 16)
4 | <main-comp>
5 |     <string-comp {42}/>
  |                   ^^
## END

## BEGIN
-- main.hop --
<user-comp {user: object[name: string, age: string]}>
	<div>{user.name} ({user.age})</div>
</user-comp>
<main-comp>
	<user-comp {'invalid'}/>
</main-comp>
-- out --
error: Argument of type string is incompatible with expected type object[age: string, name: string]
  --> main.hop (line 5, col 14)
4 | <main-comp>
5 |     <user-comp {'invalid'}/>
  |                 ^^^^^^^^^
## END

## BEGIN
-- main.hop --
<user-comp {user: object[name: string, active: string]}>
	<div>{user.name}: {user.active}</div>
</user-comp>
<main-comp {data: object[profile: object[name: string, active: string]]}>
	<user-comp {data.profile}/>
</main-comp>
-- out --
main::user-comp
	object[active: string, name: string]
	[]
main::main-comp
	object[profile: object[active: string, name: string]]
	[]
## END

## BEGIN
-- main.hop --
<new-comp {user: object[name: string]}>
	<div>{user.name}</div>
</new-comp>
<main-comp>
	<new-comp {'invalid'}/>
</main-comp>
-- out --
error: Argument of type string is incompatible with expected type object[name: string]
  --> main.hop (line 5, col 13)
4 | <main-comp>
5 |     <new-comp {'invalid'}/>
  |                ^^^^^^^^^
## END

Component with explicit string parameter type.

## BEGIN
-- main.hop --
<string-comp {message: string}>
	<div>{message}</div>
</string-comp>
-- out --
main::string-comp
	string
	[]
## END

Component with explicit object parameter type.

## BEGIN
-- main.hop --
<user-comp {user: object[name: string]}>
	<div>{user.name}</div>
</user-comp>
-- out --
main::user-comp
	object[name: string]
	[]
## END

Component with explicit array parameter type.

## BEGIN
-- main.hop --
<list-comp {items: array[string]}>
	<for {item in items}>
		<div>{item}</div>
	</for>
</list-comp>
-- out --
main::list-comp
	array[string]
	[]
## END

Component with explicit boolean parameter type.

## BEGIN
-- main.hop --
<toggle-comp {enabled: boolean}>
	<if {enabled}>
		<div>Enabled</div>
	</if>
</toggle-comp>
-- out --
main::toggle-comp
	boolean
	[]
## END

Component with explicit number parameter type.

## BEGIN
-- main.hop --
<counter-comp {count: number}>
	<if {count == 0}>
		<div>Zero</div>
	</if>
</counter-comp>
-- out --
main::counter-comp
	number
	[]
## END

Component with nested object parameter type.

## BEGIN
-- main.hop --
<profile-comp {profile: object[user: object[name: string, age: number]]}>
	<div>{profile.user.name}</div>
	<if {profile.user.age == 25}>
		<div>Quarter century</div>
	</if>
</profile-comp>
-- out --
main::profile-comp
	object[user: object[age: number, name: string]]
	[]
## END

Component with nested array parameter type.

## BEGIN
-- main.hop --
<matrix-comp {matrix: array[array[number]]}>
	<for {row in matrix}>
		<for {cell in row}>
			<if {cell == 1}>
				<span>One</span>
			</if>
		</for>
	</for>
</matrix-comp>
-- out --
main::matrix-comp
	array[array[number]]
	[]
## END

Component with complex object with multiple properties.

## BEGIN
-- main.hop --
<card-comp {data: object[title: string, content: string, tags: array[string], metadata: object[author: string, published: boolean]]}>
	<h1>{data.title}</h1>
	<p>{data.content}</p>
	<div>{data.metadata.author}</div>
	<if {data.metadata.published}>
		<span>Published</span>
	</if>
	<for {tag in data.tags}>
		<span>{tag}</span>
	</for>
</card-comp>
-- out --
main::card-comp
	object[content: string, metadata: object[author: string, published: boolean], tags: array[string], title: string]
	[]
## END

Error when passing wrong type to boolean parameter.

## BEGIN
-- main.hop --
<toggle-comp {enabled: boolean}>
	<if {enabled}>
		<div>Enabled</div>
	</if>
</toggle-comp>
<main-comp>
	<toggle-comp {'not a boolean'}/>
</main-comp>
-- out --
error: Argument of type string is incompatible with expected type boolean
  --> main.hop (line 7, col 16)
6 | <main-comp>
7 |     <toggle-comp {'not a boolean'}/>
  |                   ^^^^^^^^^^^^^^^
## END

Multi-file component with complex parameter types.

## BEGIN
-- item-display.hop --
<item-display {item: object[id: number, name: string, active: boolean]}>
	<div>{item.name}</div>
	<if {item.active}>
		<span>Active item</span>
	</if>
	<if {item.id == 1}>
		<span>First item</span>
	</if>
</item-display>
-- data-list.hop --
<import component="item-display" from="item-display">
<data-list {items: array[object[id: number, name: string, active: boolean]]}>
	<for {item in items}>
		<item-display {item}/>
	</for>
</data-list>
-- main.hop --
<import component="data-list" from="data-list">
<main-comp {items: array[object[id: number, name: string, active: boolean]]}>
	<data-list {items}/>
</main-comp>
-- out --
item-display::item-display
	object[active: boolean, id: number, name: string]
	[]
data-list::data-list
	array[object[active: boolean, id: number, name: string]]
	[]
main::main-comp
	array[object[active: boolean, id: number, name: string]]
	[]
## END

Structural subtyping should work: an object with properties a and b should be
compatible with a component that only needs property a.

## BEGIN
-- main.hop --
<needs-a {data: object[a: string]}>
	<div>{data.a}</div>
</needs-a>

<main-comp {params: object[data: object[a: string, b: string]]}>
	<needs-a {params.data}>
	</needs-a>
</main-comp>
-- out --
main::needs-a
	object[a: string]
	[]
main::main-comp
	object[data: object[a: string, b: string]]
	[]
## END
