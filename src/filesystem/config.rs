use serde::{Deserialize, Serialize};
use std::path::Path;

/// The target language for compilation
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TargetLanguage {
    #[serde(rename = "ts")]
    Typescript,
    #[serde(rename = "python")]
    Python,
    #[serde(rename = "go")]
    Go,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct HopConfig {
    #[serde(default)]
    pub css: CssConfig,

    /// Compile configuration
    pub compile: CompileConfig,

    /// Dev server configuration
    #[serde(default)]
    pub dev: DevConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct CompileConfig {
    /// The language to compile to: "ts", "go", or "python"
    pub target: Option<TargetLanguage>,

    /// The path to the file generated by the hop compiler
    pub output_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct DevConfig {
    /// The commands to run to compile and start your backend server.
    /// Used by `hop dev`.
    #[serde(default)]
    pub server_commands: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct CssConfig {
    pub mode: Option<String>,

    /// Tailwind CSS configuration
    #[serde(default)]
    pub tailwind: Option<TailwindConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct TailwindConfig {
    /// Path to the input CSS file for Tailwind
    pub input: String,
}

/// Resolved target configuration with all required fields validated
#[derive(Debug, Clone)]
pub struct ResolvedConfig {
    pub target: TargetLanguage,
    pub output_path: String,
    pub server_commands: Vec<String>,
    /// For Go targets, the package name derived from output_path
    pub go_package: Option<String>,
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Missing required field 'compile.target'. Expected one of: \"ts\", \"go\", \"python\"")]
    MissingTarget,
    #[error("Missing required field 'compile.output_path'")]
    MissingOutputPath,
}

/// Derive Go package name from output path
/// e.g., "frontend/frontend.go" -> "frontend", "main.go" -> "main"
fn derive_go_package(output_path: &str) -> String {
    let path = Path::new(output_path);
    // Get parent directory name, or use "main" as fallback
    path.parent()
        .and_then(|p| p.file_name())
        .and_then(|n| n.to_str())
        .filter(|s| !s.is_empty())
        .unwrap_or("main")
        .to_string()
}

impl HopConfig {
    /// Parse HopConfig from a TOML string and validate required fields
    pub fn from_toml_str(toml_str: &str) -> anyhow::Result<Self> {
        let config: HopConfig = toml::from_str(toml_str)?;

        // Validate required fields
        if config.compile.target.is_none() {
            return Err(ConfigError::MissingTarget.into());
        }
        if config.compile.output_path.is_none() {
            return Err(ConfigError::MissingOutputPath.into());
        }

        Ok(config)
    }

    /// Get the resolved config with all required fields validated
    pub fn get_resolved_config(&self) -> ResolvedConfig {
        let target = self
            .compile
            .target
            .expect("target should be validated by from_toml_str");
        let output_path = self
            .compile
            .output_path
            .clone()
            .expect("output_path should be validated by from_toml_str");

        let go_package = if target == TargetLanguage::Go {
            Some(derive_go_package(&output_path))
        } else {
            None
        };

        ResolvedConfig {
            target,
            output_path,
            server_commands: self.dev.server_commands.clone(),
            go_package,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;

    #[test]
    fn should_reject_config_missing_target() {
        let toml_str = indoc! {r#"
            [css]
            mode = "tailwind4"

            [compile]
            output_path = "app.ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("compile.target"));
    }

    #[test]
    fn should_reject_config_missing_output_path() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
        assert!(
            result
                .unwrap_err()
                .to_string()
                .contains("compile.output_path")
        );
    }

    #[test]
    fn should_reject_empty_config() {
        let toml_str = "";
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
    }

    #[test]
    fn should_accept_config_with_typescript_target() {
        let toml_str = indoc! {r#"
            [css]
            mode = "tailwind4"

            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.css.mode, Some("tailwind4".to_string()));
        assert_eq!(config.compile.target, Some(TargetLanguage::Typescript));
        assert_eq!(config.compile.output_path, Some("app.ts".to_string()));
    }

    #[test]
    fn should_accept_and_resolve_config_with_validated_fields() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config();
        assert_eq!(resolved.target, TargetLanguage::Typescript);
        assert_eq!(resolved.output_path, "app.ts");
        assert!(resolved.server_commands.is_empty());
        assert!(resolved.go_package.is_none());
    }

    #[test]
    fn should_accept_config_with_server_commands() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"

            [dev]
            server_commands = ["npm install", "npm start"]
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config();
        assert_eq!(resolved.target, TargetLanguage::Typescript);
        assert_eq!(resolved.output_path, "app.ts");
        assert_eq!(resolved.server_commands, vec!["npm install", "npm start"]);
    }

    #[test]
    fn should_accept_config_without_server_commands() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Typescript));
        assert!(config.dev.server_commands.is_empty());
    }

    #[test]
    fn should_accept_config_with_tailwind() {
        let toml_str = indoc! {r#"
            [css.tailwind]
            input = "styles/input.css"

            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert!(config.css.tailwind.is_some());
        assert_eq!(config.css.tailwind.unwrap().input, "styles/input.css");
    }

    #[test]
    fn should_reject_config_with_unknown_field() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
            unknown_field = "should error"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
        let error_msg = result.unwrap_err().to_string();
        assert!(error_msg.contains("unknown_field"));
    }

    #[test]
    fn should_accept_config_with_go_target() {
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "frontend/frontend.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config();

        assert_eq!(resolved.target, TargetLanguage::Go);
        assert_eq!(resolved.output_path, "frontend/frontend.go");
        // Package should be derived from parent directory
        assert_eq!(resolved.go_package, Some("frontend".to_string()));
    }

    #[test]
    fn should_derive_go_package_as_main_for_root_path() {
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "main.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config();

        // When output is in root, package should default to "main"
        assert_eq!(resolved.go_package, Some("main".to_string()));
    }

    #[test]
    fn should_reject_config_with_invalid_target() {
        let toml_str = indoc! {r#"
            [compile]
            target = "invalid"
            output_path = "app.ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
    }

    #[test]
    fn should_accept_all_valid_target_values() {
        // Test "ts"
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Typescript));

        // Test "go"
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "main.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Go));

        // Test "python"
        let toml_str = indoc! {r#"
            [compile]
            target = "python"
            output_path = "app.py"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Python));
    }

    #[test]
    fn should_reject_full_target_names() {
        // "typescript" should be rejected (only "ts" is valid)
        let toml_str = indoc! {r#"
            [compile]
            target = "typescript"
            output_path = "app.ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());

        // "javascript" should be rejected (it's no longer a valid target)
        let toml_str = indoc! {r#"
            [compile]
            target = "javascript"
            output_path = "app.js"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());

        // "js" should be rejected (it's no longer a valid target)
        let toml_str = indoc! {r#"
            [compile]
            target = "js"
            output_path = "app.js"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
    }

    #[test]
    fn should_derive_go_package_from_output_path() {
        assert_eq!(derive_go_package("frontend/frontend.go"), "frontend");
        assert_eq!(derive_go_package("main.go"), "main");
        assert_eq!(derive_go_package("src/components/views.go"), "components");
        assert_eq!(derive_go_package("./output.go"), "main");
    }
}
