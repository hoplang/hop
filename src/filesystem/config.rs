use serde::{Deserialize, Serialize};
use std::path::Path;

/// The target language for compilation
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TargetLanguage {
    #[serde(rename = "ts")]
    Typescript,
    #[serde(rename = "python")]
    Python,
    #[serde(rename = "go")]
    Go,
    #[serde(rename = "rust")]
    Rust,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct HopConfig {
    #[serde(default)]
    pub css: CssConfig,

    /// Compile configuration (optional - only needed for `hop compile`)
    #[serde(default)]
    pub compile: CompileConfig,

    /// Dev server configuration
    #[serde(default)]
    pub dev: DevConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct CompileConfig {
    /// The language to compile to: "ts", "go", "python", or "rust"
    pub target: Option<TargetLanguage>,

    /// The path to the file generated by the hop compiler
    pub output_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct DevConfig {}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(deny_unknown_fields)]
pub struct CssConfig {
    pub mode: Option<String>,

    /// Tailwind CSS configuration
    #[serde(default)]
    pub tailwind: Option<TailwindConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct TailwindConfig {
    /// Path to the input CSS file for Tailwind
    pub input: String,
}

/// Resolved target configuration with all required fields validated
#[derive(Debug, Clone)]
pub struct ResolvedConfig {
    pub target: TargetLanguage,
    pub output_path: String,
    /// For Go targets, the package name derived from output_path
    pub go_package: Option<String>,
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error(
        "Missing 'compile.target' in hop.toml. Expected one of: \"ts\", \"go\", \"python\", \"rust\""
    )]
    MissingTarget,
    #[error("Missing 'compile.output_path' in hop.toml")]
    MissingOutputPath,
}

/// Derive Go package name from output path
/// e.g., "frontend/frontend.go" -> "frontend", "main.go" -> "main"
fn derive_go_package(output_path: &str) -> String {
    let path = Path::new(output_path);
    // Get parent directory name, or use "main" as fallback
    path.parent()
        .and_then(|p| p.file_name())
        .and_then(|n| n.to_str())
        .filter(|s| !s.is_empty())
        .unwrap_or("main")
        .to_string()
}

impl HopConfig {
    /// Parse HopConfig from a TOML string
    pub fn from_toml_str(toml_str: &str) -> anyhow::Result<Self> {
        let config: HopConfig = toml::from_str(toml_str)?;
        Ok(config)
    }

    /// Get the resolved config with all required compile fields validated.
    /// Returns an error if `compile.target` or `compile.output_path` are missing.
    pub fn get_resolved_config(&self) -> Result<ResolvedConfig, ConfigError> {
        let target = self.compile.target.ok_or(ConfigError::MissingTarget)?;
        let output_path = self
            .compile
            .output_path
            .clone()
            .ok_or(ConfigError::MissingOutputPath)?;

        let go_package = if target == TargetLanguage::Go {
            Some(derive_go_package(&output_path))
        } else {
            None
        };

        Ok(ResolvedConfig {
            target,
            output_path,
            go_package,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;

    #[test]
    fn should_accept_config_with_typescript_target() {
        let toml_str = indoc! {r#"
            [css]
            mode = "tailwind4"

            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.css.mode, Some("tailwind4".to_string()));
        assert_eq!(config.compile.target, Some(TargetLanguage::Typescript));
        assert_eq!(config.compile.output_path, Some("app.ts".to_string()));
    }

    #[test]
    fn should_accept_and_resolve_config_with_validated_fields() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config().unwrap();
        assert_eq!(resolved.target, TargetLanguage::Typescript);
        assert_eq!(resolved.output_path, "app.ts");
        assert!(resolved.go_package.is_none());
    }

    #[test]
    fn should_accept_config_with_tailwind() {
        let toml_str = indoc! {r#"
            [css.tailwind]
            input = "styles/input.css"

            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert!(config.css.tailwind.is_some());
        assert_eq!(config.css.tailwind.unwrap().input, "styles/input.css");
    }

    #[test]
    fn should_reject_config_with_unknown_field() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
            unknown_field = "should error"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
        let error_msg = result.unwrap_err().to_string();
        assert!(error_msg.contains("unknown_field"));
    }

    #[test]
    fn should_accept_config_with_go_target() {
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "frontend/frontend.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config().unwrap();

        assert_eq!(resolved.target, TargetLanguage::Go);
        assert_eq!(resolved.output_path, "frontend/frontend.go");
        // Package should be derived from parent directory
        assert_eq!(resolved.go_package, Some("frontend".to_string()));
    }

    #[test]
    fn should_derive_go_package_as_main_for_root_path() {
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "main.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let resolved = config.get_resolved_config().unwrap();

        // When output is in root, package should default to "main"
        assert_eq!(resolved.go_package, Some("main".to_string()));
    }

    #[test]
    fn should_reject_config_with_invalid_target() {
        let toml_str = indoc! {r#"
            [compile]
            target = "invalid"
            output_path = "app.ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
    }

    #[test]
    fn should_accept_all_valid_target_values() {
        // Test "ts"
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Typescript));

        // Test "go"
        let toml_str = indoc! {r#"
            [compile]
            target = "go"
            output_path = "main.go"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Go));

        // Test "python"
        let toml_str = indoc! {r#"
            [compile]
            target = "python"
            output_path = "app.py"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        assert_eq!(config.compile.target, Some(TargetLanguage::Python));
    }

    #[test]
    fn should_reject_full_target_names() {
        // "typescript" should be rejected (only "ts" is valid)
        let toml_str = indoc! {r#"
            [compile]
            target = "typescript"
            output_path = "app.ts"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());

        // "javascript" should be rejected (it's no longer a valid target)
        let toml_str = indoc! {r#"
            [compile]
            target = "javascript"
            output_path = "app.js"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());

        // "js" should be rejected (it's no longer a valid target)
        let toml_str = indoc! {r#"
            [compile]
            target = "js"
            output_path = "app.js"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(result.is_err());
    }

    #[test]
    fn should_derive_go_package_from_output_path() {
        assert_eq!(derive_go_package("frontend/frontend.go"), "frontend");
        assert_eq!(derive_go_package("main.go"), "main");
        assert_eq!(derive_go_package("src/components/views.go"), "components");
        assert_eq!(derive_go_package("./output.go"), "main");
    }

    #[test]
    fn should_parse_config_without_compile_section() {
        let toml_str = indoc! {r#"
            [css]
            mode = "tailwind4"
        "#};
        let result = HopConfig::from_toml_str(toml_str);
        assert!(
            result.is_ok(),
            "Config without compile section should parse: {:?}",
            result.err()
        );
    }

    #[test]
    fn should_parse_empty_config() {
        let toml_str = "";
        let result = HopConfig::from_toml_str(toml_str);
        assert!(
            result.is_ok(),
            "Empty config should parse: {:?}",
            result.err()
        );
    }

    #[test]
    fn get_resolved_config_should_error_on_missing_target() {
        let toml_str = indoc! {r#"
            [compile]
            output_path = "app.ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let result = config.get_resolved_config();
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("compile.target"));
        assert!(err_msg.contains("hop.toml"));
    }

    #[test]
    fn get_resolved_config_should_error_on_missing_output_path() {
        let toml_str = indoc! {r#"
            [compile]
            target = "ts"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let result = config.get_resolved_config();
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("compile.output_path"));
        assert!(err_msg.contains("hop.toml"));
    }

    #[test]
    fn get_resolved_config_should_error_when_no_compile_section() {
        let toml_str = indoc! {r#"
            [css]
            mode = "tailwind4"
        "#};
        let config = HopConfig::from_toml_str(toml_str).unwrap();
        let result = config.get_resolved_config();
        assert!(result.is_err());
    }
}
