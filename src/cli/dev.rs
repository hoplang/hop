use crate::filesystem::adaptive_watcher::{AdaptiveWatcher, WatchEvent};
use crate::filesystem::project_root::ProjectRoot;
use crate::hop::component_name::ComponentName;
use crate::hop::module_name::ModuleName;
use crate::hop::program::Program;
use axum::body::Body;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::Response;
use std::path::PathBuf;
use std::sync::{Arc, RwLock};
use tailwind_runner::TailwindRunner;
use tokio::process::Child;

pub struct DevelopmentServer {
    pub router: axum::Router,
    _hop_watcher: AdaptiveWatcher,
    _css_watcher: notify::RecommendedWatcher,
    pub tailwind_process: Child,
}

#[derive(Clone)]
struct AppState {
    // The compiled hop program.
    program: Arc<RwLock<Program>>,

    // Reload channel where the file watchers send hot-reload events.
    // These events are propagated to the event stream route.
    reload_channel: tokio::sync::broadcast::Sender<()>,

    // The output path where the tailwind process writes the generated CSS.
    tailwind_css_output_path: Arc<PathBuf>,

    // The CSS generated by tailwind.
    tailwind_css: Arc<RwLock<Option<String>>>,

    // Handle to the temporary directory, containing the tailwind output
    // file and the tailwind binary etc.
    _tmp_dir: Arc<tempfile::TempDir>,
}

async fn handle_development_mode_js() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "application/javascript")
        .header("Cache-Control", "public, max-age=31536000, immutable")
        .body(Body::from(include_str!("./js/development_mode.js")))
        .unwrap()
}

async fn handle_event_source(
    State(state): State<AppState>,
) -> axum::response::sse::Sse<
    impl tokio_stream::Stream<Item = Result<axum::response::sse::Event, axum::Error>>,
> {
    use axum::response::sse::{Event, Sse};
    use tokio_stream::StreamExt;

    Sse::new(
        tokio_stream::wrappers::BroadcastStream::new(state.reload_channel.subscribe())
            .map(|_| Ok::<Event, axum::Error>(Event::default().data("reload"))),
    )
}

#[derive(serde::Deserialize)]
struct RenderParams {
    module: String,
    component: String,
    params: std::collections::HashMap<String, serde_json::Value>,
}

async fn handle_render(
    State(state): State<AppState>,
    axum::Json(body): axum::Json<RenderParams>,
) -> Response<Body> {
    let program = state.program.read().unwrap();

    // Get the CSS content from state
    let css = state.tailwind_css.read().unwrap();
    let css_content = css.as_deref();

    // Parse module name
    let module_name = match ModuleName::new(body.module.clone()) {
        Ok(name) => name,
        Err(e) => {
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(format!("Invalid module name: {}", e)))
                .unwrap();
        }
    };

    // Parse component name
    let component_name = match ComponentName::new(body.component.clone()) {
        Ok(name) => name,
        Err(e) => {
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(format!("Invalid component name: {}", e)))
                .unwrap();
        }
    };

    match program.evaluate_ir_entrypoint(&module_name, &component_name, body.params, css_content) {
        Ok(html) => Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "text/html")
            .body(Body::from(html))
            .unwrap(),
        Err(e) => Response::builder()
            .status(StatusCode::INTERNAL_SERVER_ERROR)
            .header("Content-Type", "text/html")
            .body(Body::from(format!("Error rendering component: {}", e)))
            .unwrap(),
    }
}

async fn start_tailwind_watcher(
    root: &ProjectRoot,
    tmp_dir: &tempfile::TempDir,
) -> anyhow::Result<(String, PathBuf, Child)> {
    let input_path = match root.get_tailwind_input_path().await? {
        Some(p) => p,
        None => {
            let temp_input = tmp_dir.path().join("default-input.css");
            let default_content = r#"@import "tailwindcss";"#;
            tokio::fs::write(&temp_input, default_content).await?;
            temp_input
        }
    };

    let cache_dir = tmp_dir.path().to_path_buf();
    let runner = TailwindRunner::new(cache_dir.clone()).await?;

    let output_path = cache_dir.join("tailwind-output.css");
    let tailwind_config = tailwind_runner::TailwindConfig {
        input: input_path.to_path_buf(),
        output: output_path.clone(),
    };

    // Run once initially to generate CSS - return error if it fails
    runner.run_once(&tailwind_config).await?;

    // Read the generated CSS file
    let css_content = tokio::fs::read_to_string(&tailwind_config.output).await?;

    // Start watcher
    let handle = runner.watch(&tailwind_config)?;

    Ok((css_content, output_path, handle))
}

async fn create_file_watcher(
    root: &ProjectRoot,
    state: AppState,
) -> anyhow::Result<(AdaptiveWatcher, notify::RecommendedWatcher)> {
    let local_root = root.clone();

    // Create adaptive watcher with ignored folders for the project directory
    let ignored_folders = vec![".git", ".direnv", "node_modules", "target"];

    let adaptive_watcher = AdaptiveWatcher::new(root.get_path(), ignored_folders).await?;

    // Spawn task to handle watch events from the adaptive watcher
    let mut rx = adaptive_watcher.subscribe();
    let state_clone = state.clone();
    tokio::spawn(async move {
        while let Ok(event) = rx.recv().await {
            match event {
                WatchEvent::Created(path)
                | WatchEvent::Modified(path)
                | WatchEvent::Deleted(path) => {
                    // Check if it's a .hop file
                    let is_hop_file = path.extension().and_then(|e| e.to_str()) == Some("hop");

                    if is_hop_file {
                        // Reload all modules from scratch
                        if let Ok(modules) = local_root.load_all_hop_modules() {
                            let new_program = Program::new(modules);
                            if let Ok(mut program) = state_clone.program.write() {
                                *program = new_program;
                            }
                        }
                        // Tell the client to hot reload
                        let _ = state_clone.reload_channel.send(());
                    }
                }
            }
        }
    });

    // Create a separate watcher for the CSS output file
    use notify::Watcher;
    let css_output_path = state.tailwind_css_output_path.as_ref().clone();
    let state_for_css_watcher = state.clone();
    let mut css_watcher = notify::RecommendedWatcher::new(
        move |res: Result<notify::Event, notify::Error>| {
            if let Ok(event) = res {
                if event.kind.is_modify() {
                    if let Ok(new_css) = std::fs::read_to_string(
                        state_for_css_watcher.tailwind_css_output_path.as_path(),
                    ) {
                        if let Ok(mut css_guard) = state.tailwind_css.write() {
                            *css_guard = Some(new_css);
                        }
                    }
                    // Tell the client to hot reload
                    let _ = state_for_css_watcher.reload_channel.send(());
                }
            }
        },
        notify::Config::default(),
    )?;

    // Watch the CSS output file
    css_watcher.watch(&css_output_path, notify::RecursiveMode::NonRecursive)?;

    Ok((adaptive_watcher, css_watcher))
}

fn create_router() -> axum::Router<AppState> {
    use axum::routing::{get, post};
    use tower_http::cors::{Any, CorsLayer};

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    axum::Router::new()
        .route("/development_mode.js", get(handle_development_mode_js))
        .route("/event_source", get(handle_event_source))
        .route("/render", post(handle_render))
        .layer(cors)
}

/// Create a router that responds to render requests.
///
/// Also sets up a watcher that watches all source files used to construct the output files.
/// The watcher emits SSE-events on the `/event_source` route.
pub async fn execute(root: &ProjectRoot) -> anyhow::Result<DevelopmentServer> {
    let modules = root.load_all_hop_modules()?;

    let tmp_dir = tempfile::tempdir()?;

    let (css_content, css_output_path, tailwind_handle) =
        start_tailwind_watcher(root, &tmp_dir).await?;

    let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);

    let app_state = AppState {
        program: Arc::new(RwLock::new(Program::new(modules))),
        reload_channel,
        tailwind_css: Arc::new(RwLock::new(Some(css_content))),
        _tmp_dir: Arc::new(tmp_dir),
        tailwind_css_output_path: Arc::new(css_output_path.clone()),
    };

    let (adaptive_watcher, css_watcher) = create_file_watcher(root, app_state.clone()).await?;

    let router = create_router().with_state(app_state);

    Ok(DevelopmentServer {
        router,
        _hop_watcher: adaptive_watcher,
        _css_watcher: css_watcher,
        tailwind_process: tailwind_handle,
    })
}

///////////////////////////////////////////////////////////////////////////////
// TESTS                                                                     //
///////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use crate::hop::module_name::ModuleName;
    use axum_test::TestServer;
    use expect_test::expect;
    use serde_json::json;
    use simple_txtar::Archive;

    fn create_test_server(input: &str) -> TestServer {
        let archive = Archive::from(input);
        let mut modules = HashMap::new();
        for file in archive.iter() {
            let module_name = ModuleName::new(file.name.replace(".hop", "")).unwrap();
            modules.insert(module_name, file.content.clone());
        }
        let program = Program::new(modules);
        let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);
        let tmp_dir = tempfile::tempdir().unwrap();
        let css_output_path = tmp_dir.path().join("tailwind-output.css");

        let app_state = AppState {
            program: Arc::new(RwLock::new(program)),
            reload_channel,
            tailwind_css: Arc::new(RwLock::new(None)),
            _tmp_dir: Arc::new(tmp_dir),
            tailwind_css_output_path: Arc::new(css_output_path),
        };

        let router = axum::Router::new()
            .route("/render", axum::routing::post(handle_render))
            .with_state(app_state);

        TestServer::new(router).unwrap()
    }

    /// Tests that the render endpoint correctly renders a component with props.
    #[tokio::test]
    async fn test_render_component_with_parameters() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <GreetingComp {name: String, title: String}>
              <h1>{title}</h1>
              <p>Hello, {name}!</p>
            </GreetingComp>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "test",
                "component": "GreetingComp",
                "params": {
                    "name": "Alice",
                    "title": "Welcome",
                }
            }))
            .await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html>
              <html><head></head><body><h1>Welcome</h1>
              <p>Hello, Alice!</p>
            </body></html>"#]]
        .assert_eq(&response.text());
    }

    /// Tests that the render endpoint correctly renders a component with no props.
    #[tokio::test]
    async fn test_render_component_without_parameters() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <SimpleComp>
              <div>Simple content</div>
            </SimpleComp>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "test",
                "component": "SimpleComp",
                "params": {}
            }))
            .await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html>
              <html><head></head><body><div>Simple content</div>
            </body></html>"#]]
        .assert_eq(&response.text());
    }

    /// Tests that requesting a component that doesn't exist returns a 500 error
    /// with a helpful message listing the available components in that module.
    #[tokio::test]
    async fn test_render_nonexistent_component_returns_error() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <GreetingComp {name: String}>
              <p>Hello, {name}!</p>
            </GreetingComp>

            <SimpleComp>
              <div>Simple content</div>
            </SimpleComp>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "test",
                "component": "NonExistent",
                "params": {}
            }))
            .await;

        response.assert_status_internal_server_error();
        expect!["Error rendering component: Component 'NonExistent' not found in module 'test'. Available components: GreetingComp, SimpleComp"]
            .assert_eq(&response.text());
    }

    /// Tests that sending malformed JSON to the render endpoint returns a 400 Bad Request.
    #[tokio::test]
    async fn test_render_invalid_json_returns_bad_request() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <SimpleComp>
              <div>Simple content</div>
            </SimpleComp>
        "#});

        let response = server
            .post("/render")
            .text("invalid-json")
            .content_type("application/json")
            .await;

        response.assert_status_bad_request();

        expect!["Failed to parse the request body as JSON: expected value at line 1 column 1"]
            .assert_eq(&response.text());
    }

    /// Tests that requesting a component from a module with syntax errors returns an error.
    #[tokio::test]
    async fn test_render_component_with_syntax_error() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <FooComp>
              <div>Foo</div>
            </FooComp>

            <BrokenComp {name: String}>
              <p>Hello, {name}!</p>
            </BrokenComp
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "test",
                "component": "FooComp",
                "params": {}
            }))
            .await;

        response.assert_status_internal_server_error();
        expect![[
            r#"Error rendering component: Module 'test' has syntax errors:
  - Unterminated closing tag
  - Unclosed <BrokenComp>"#
        ]]
        .assert_eq(&response.text());
    }

    /// Tests that a syntax error in an unrelated module still prevents rendering.
    #[tokio::test]
    async fn test_render_fails_when_unrelated_module_has_syntax_error() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            <GoodComp>
              <div>This is fine</div>
            </GoodComp>

            -- broken.hop --
            <BrokenComp>
              <div>Broken
            </BrokenComp>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "good",
                "component": "GoodComp",
                "params": {}
            }))
            .await;

        response.assert_status_internal_server_error();
        expect![[
            r#"Error rendering component: Module 'broken' has syntax errors:
  - Unclosed <div>"#
        ]]
        .assert_eq(&response.text());
    }

    /// Tests that requesting a component from a module with type errors returns an error.
    #[tokio::test]
    async fn test_render_component_with_type_error() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            <Foo {name: String}>
              <p>{name}</p>
            </Foo>

            <Bar>
              <Foo {name: undefined_variable} />
            </Bar>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "test",
                "component": "Bar",
                "params": {}
            }))
            .await;

        response.assert_status_internal_server_error();
        expect![
            [r#"Error rendering component: Module 'test' has type errors:
  - Undefined variable: undefined_variable"#]
        ]
        .assert_eq(&response.text());
    }

    /// Tests that a component can import and use another component from a different module.
    #[tokio::test]
    async fn test_render_component_with_import() {
        let server = create_test_server(indoc::indoc! {r#"
            -- components.hop --
            <Button {label: String}>
              <button>{label}</button>
            </Button>

            -- page.hop --
            import Button from "@/components"

            <Page>
              <div><Button {label: "Click me"} /></div>
            </Page>
        "#});

        let response = server
            .post("/render")
            .json(&json!({
                "module": "page",
                "component": "Page",
                "params": {}
            }))
            .await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html>
              <html><head></head><body><div>
              <button>Click me</button>
            </div>
            </body></html>"#]]
        .assert_eq(&response.text());
    }
}
