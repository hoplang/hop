use crate::filesystem::adaptive_watcher::{AdaptiveWatcher, WatchEvent};
use crate::filesystem::project_root::ProjectRoot;
use crate::hop::program::Program;
use axum::body::Body;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::Response;
use std::path::PathBuf;
use std::sync::{Arc, RwLock};
use tailwind_runner::TailwindRunner;
use tokio::process::Child;

pub struct DevelopmentServer {
    pub router: axum::Router,
    _hop_watcher: AdaptiveWatcher,
    _css_watcher: notify::RecommendedWatcher,
    pub tailwind_process: Child,
}

#[derive(Clone)]
struct AppState {
    // The compiled hop program.
    program: Arc<RwLock<Program>>,

    // Reload channel where the file watchers send hot-reload events.
    // These events are propagated to the event stream route.
    reload_channel: tokio::sync::broadcast::Sender<()>,

    // The output path where the tailwind process writes the generated CSS.
    tailwind_css_output_path: Arc<PathBuf>,

    // The CSS generated by tailwind.
    tailwind_css: Arc<RwLock<Option<String>>>,

    // Handle to the temporary directory, containing the tailwind output
    // file and the tailwind binary etc.
    _tmp_dir: Arc<tempfile::TempDir>,
}

async fn handle_development_mode_js() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "application/javascript")
        .header("Cache-Control", "public, max-age=31536000, immutable")
        .body(Body::from(include_str!("./js/development_mode.js")))
        .unwrap()
}

async fn handle_event_source(
    State(state): State<AppState>,
) -> axum::response::sse::Sse<
    impl tokio_stream::Stream<Item = Result<axum::response::sse::Event, axum::Error>>,
> {
    use axum::response::sse::{Event, Sse};
    use tokio_stream::StreamExt;

    Sse::new(
        tokio_stream::wrappers::BroadcastStream::new(state.reload_channel.subscribe())
            .map(|_| Ok::<Event, axum::Error>(Event::default().data("reload"))),
    )
}

#[derive(serde::Deserialize)]
struct RenderParams {
    module: String,
    component: String,
    params: std::collections::HashMap<String, serde_json::Value>,
}

async fn handle_render(
    State(state): State<AppState>,
    axum::Json(body): axum::Json<RenderParams>,
) -> Response<Body> {
    let program = state.program.read().unwrap();

    // Get the CSS content from state
    let css = state.tailwind_css.read().unwrap();
    let css_content = css.as_deref();

    // Parse module name
    let module_name = match crate::hop::module_name::ModuleName::new(body.module.clone()) {
        Ok(name) => name,
        Err(e) => {
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(format!("Invalid module name: {}", e)))
                .unwrap();
        }
    };

    match program.evaluate_ir_entrypoint(&module_name, &body.component, body.params, "dev", css_content) {
        Ok(html) => Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "text/html")
            .body(Body::from(html))
            .unwrap(),
        Err(e) => Response::builder()
            .status(StatusCode::INTERNAL_SERVER_ERROR)
            .header("Content-Type", "text/html")
            .body(Body::from(format!("Error rendering component: {}", e)))
            .unwrap(),
    }
}

async fn start_tailwind_watcher(
    root: &ProjectRoot,
    tmp_dir: &tempfile::TempDir,
) -> anyhow::Result<(String, PathBuf, Child)> {
    let input_path = match root.get_tailwind_input_path().await? {
        Some(p) => p,
        None => {
            let temp_input = tmp_dir.path().join("default-input.css");
            let default_content = r#"@import "tailwindcss";"#;
            tokio::fs::write(&temp_input, default_content).await?;
            temp_input
        }
    };

    let cache_dir = tmp_dir.path().to_path_buf();
    let runner = TailwindRunner::new(cache_dir.clone()).await?;

    let output_path = cache_dir.join("tailwind-output.css");
    let tailwind_config = tailwind_runner::TailwindConfig {
        input: input_path.to_path_buf(),
        output: output_path.clone(),
    };

    // Run once initially to generate CSS - return error if it fails
    runner.run_once(&tailwind_config).await?;

    // Read the generated CSS file
    let css_content = tokio::fs::read_to_string(&tailwind_config.output).await?;

    // Start watcher
    let handle = runner.watch(&tailwind_config)?;

    Ok((css_content, output_path, handle))
}

async fn create_file_watcher(
    root: &ProjectRoot,
    state: AppState,
) -> anyhow::Result<(AdaptiveWatcher, notify::RecommendedWatcher)> {
    let local_root = root.clone();

    // Create adaptive watcher with ignored folders for the project directory
    let ignored_folders = vec![".git", ".direnv", "node_modules", "target"];

    let adaptive_watcher = AdaptiveWatcher::new(root.get_path(), ignored_folders).await?;

    // Spawn task to handle watch events from the adaptive watcher
    let mut rx = adaptive_watcher.subscribe();
    let state_clone = state.clone();
    tokio::spawn(async move {
        while let Ok(event) = rx.recv().await {
            match event {
                WatchEvent::Created(path)
                | WatchEvent::Modified(path)
                | WatchEvent::Deleted(path) => {
                    // Check if it's a .hop file
                    let is_hop_file = path.extension().and_then(|e| e.to_str()) == Some("hop");

                    if is_hop_file {
                        // Reload all modules from scratch
                        if let Ok(modules) = local_root.load_all_hop_modules() {
                            let new_program = Program::new(modules);
                            if let Ok(mut program) = state_clone.program.write() {
                                *program = new_program;
                            }
                        }
                        // Tell the client to hot reload
                        let _ = state_clone.reload_channel.send(());
                    }
                }
            }
        }
    });

    // Create a separate watcher for the CSS output file
    use notify::Watcher;
    let css_output_path = state.tailwind_css_output_path.as_ref().clone();
    let state_for_css_watcher = state.clone();
    let mut css_watcher = notify::RecommendedWatcher::new(
        move |res: Result<notify::Event, notify::Error>| {
            if let Ok(event) = res {
                if event.kind.is_modify() {
                    if let Ok(new_css) = std::fs::read_to_string(
                        state_for_css_watcher.tailwind_css_output_path.as_path(),
                    ) {
                        if let Ok(mut css_guard) = state.tailwind_css.write() {
                            *css_guard = Some(new_css);
                        }
                    }
                    // Tell the client to hot reload
                    let _ = state_for_css_watcher.reload_channel.send(());
                }
            }
        },
        notify::Config::default(),
    )?;

    // Watch the CSS output file
    css_watcher.watch(&css_output_path, notify::RecursiveMode::NonRecursive)?;

    Ok((adaptive_watcher, css_watcher))
}

fn create_router() -> axum::Router<AppState> {
    use axum::routing::{get, post};
    use tower_http::cors::{Any, CorsLayer};

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    axum::Router::new()
        .route("/development_mode.js", get(handle_development_mode_js))
        .route("/event_source", get(handle_event_source))
        .route("/render", post(handle_render))
        .layer(cors)
}

/// Create a router that responds to render requests.
///
/// Also sets up a watcher that watches all source files used to construct the output files.
/// The watcher emits SSE-events on the `/event_source` route.
pub async fn execute(root: &ProjectRoot) -> anyhow::Result<DevelopmentServer> {
    let modules = root.load_all_hop_modules()?;

    let tmp_dir = tempfile::tempdir()?;

    let (css_content, css_output_path, tailwind_handle) =
        start_tailwind_watcher(root, &tmp_dir).await?;

    let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);

    let app_state = AppState {
        program: Arc::new(RwLock::new(Program::new(modules))),
        reload_channel,
        tailwind_css: Arc::new(RwLock::new(Some(css_content))),
        _tmp_dir: Arc::new(tmp_dir),
        tailwind_css_output_path: Arc::new(css_output_path.clone()),
    };

    let (adaptive_watcher, css_watcher) = create_file_watcher(root, app_state.clone()).await?;

    let router = create_router().with_state(app_state);

    Ok(DevelopmentServer {
        router,
        _hop_watcher: adaptive_watcher,
        _css_watcher: css_watcher,
        tailwind_process: tailwind_handle,
    })
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use axum::body::to_bytes;
    use axum::http::Request;
    use expect_test::expect;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_handle_render_with_ir_entrypoint() {
        // Create a test program with an entrypoint
        let mut modules = HashMap::new();
        modules.insert(
            crate::hop::module_name::ModuleName::new("test".to_string()).unwrap(),
            r#"
            <GreetingComp {name: String, title: String}><h1>{title}</h1><p>Hello, {name}!</p></GreetingComp>

            <SimpleComp><div>Simple content</div></SimpleComp>
            "#
            .to_string(),
        );

        let program = Program::new(modules);
        let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);
        let tmp_dir = tempfile::tempdir().unwrap();
        let css_output_path = tmp_dir.path().join("tailwind-output.css");

        let app_state = AppState {
            program: Arc::new(RwLock::new(program)),
            reload_channel,
            tailwind_css: Arc::new(RwLock::new(None)),
            _tmp_dir: Arc::new(tmp_dir),
            tailwind_css_output_path: Arc::new(css_output_path),
        };

        let app = axum::Router::new()
            .route("/render", axum::routing::post(handle_render))
            .with_state(app_state);

        // Test rendering with parameters
        let body_json = serde_json::json!({
            "module": "test",
            "component": "GreetingComp",
            "params": {
                "name": "Alice",
                "title": "Welcome"
            }
        });

        let request = Request::builder()
            .uri("/render")
            .method("POST")
            .header("Content-Type", "application/json")
            .body(Body::from(body_json.to_string()))
            .unwrap();

        let response = app.clone().oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);

        let body = to_bytes(response.into_body(), usize::MAX).await.unwrap();
        let html = String::from_utf8(body.to_vec()).unwrap();

        expect!["<!DOCTYPE html><html><head></head><body><h1>Welcome</h1><p>Hello, Alice!</p></body></html>"].assert_eq(&html);

        // Test rendering without parameters
        let body_json = serde_json::json!({
            "module": "test",
            "component": "SimpleComp",
            "params": {}
        });

        let request = Request::builder()
            .uri("/render")
            .method("POST")
            .header("Content-Type", "application/json")
            .body(Body::from(body_json.to_string()))
            .unwrap();

        let response = app.clone().oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);

        let body = to_bytes(response.into_body(), usize::MAX).await.unwrap();
        let html = String::from_utf8(body.to_vec()).unwrap();

        expect!["<!DOCTYPE html><html><head></head><body><div>Simple content</div></body></html>"]
            .assert_eq(&html);

        // Test non-existent entrypoint
        let body_json = serde_json::json!({
            "module": "test",
            "component": "NonExistent",
            "params": {}
        });

        let request = Request::builder()
            .uri("/render")
            .method("POST")
            .header("Content-Type", "application/json")
            .body(Body::from(body_json.to_string()))
            .unwrap();

        let response = app.clone().oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);

        let body = to_bytes(response.into_body(), usize::MAX).await.unwrap();
        let error_msg = String::from_utf8(body.to_vec()).unwrap();

        expect!["Error rendering component: Component 'NonExistent' not found in module 'test'. Available components: GreetingComp, SimpleComp"]
            .assert_eq(&error_msg);

        // Test invalid JSON body
        let request = Request::builder()
            .uri("/render")
            .method("POST")
            .header("Content-Type", "application/json")
            .body(Body::from("invalid-json"))
            .unwrap();

        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::BAD_REQUEST);
    }
}
