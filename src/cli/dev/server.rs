use super::frontend;
use crate::document::DocumentAnnotator;
use crate::hop::program::Program;
use crate::hop::symbols::component_name::ComponentName;
use crate::hop::symbols::module_name::ModuleName;
use crate::log_info;
use axum::body::Body;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::Response;
use std::sync::{Arc, RwLock};

#[derive(Clone)]
pub struct AppState {
    // The compiled hop program.
    pub program: Arc<RwLock<Program>>,

    // Reload channel where the file watchers send hot-reload events.
    // These events are propagated to the event stream listeners.
    pub reload_channel: tokio::sync::broadcast::Sender<()>,

    // The CSS generated by tailwind.
    pub tailwind_css: Arc<RwLock<Option<String>>>,
}

async fn handle_program(State(state): State<AppState>) -> Response<Body> {
    let _program = state.program.read().unwrap();

    let mut modules = Vec::new();

    for (module_name, ast) in _program.get_typed_modules() {
        let mut components = Vec::new();
        for c in ast.get_component_declarations() {
            components.push(c.component_name.to_string());
        }
        modules.push(frontend::Module {
            name: module_name.to_string(),
            components,
        })
    }

    let html = frontend::program(frontend::ProgramParams { modules: &modules });

    Response::builder()
        .header("Content-Type", "text/html")
        .body(Body::from(html))
        .unwrap()
}

async fn handle_development_mode_js() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "application/javascript")
        .header("Cache-Control", "public, max-age=31536000, immutable")
        .body(Body::from(include_str!("./js/development_mode.js")))
        .unwrap()
}

async fn handle_event_source(
    State(state): State<AppState>,
) -> axum::response::sse::Sse<
    impl tokio_stream::Stream<Item = Result<axum::response::sse::Event, axum::Error>>,
> {
    use axum::response::sse::{Event, Sse};
    use std::sync::atomic::{AtomicU64, Ordering};
    use tokio_stream::StreamExt;

    static CONNECTION_ID: AtomicU64 = AtomicU64::new(0);
    let id = CONNECTION_ID.fetch_add(1, Ordering::Relaxed);

    log_info!("sse", event = "connected", client_id = id);

    Sse::new(
        tokio_stream::wrappers::BroadcastStream::new(state.reload_channel.subscribe()).map(
            move |_| {
                log_info!("sse", event = "reload", client_id = id);
                Ok::<Event, axum::Error>(Event::default().data("reload"))
            },
        ),
    )
}

#[derive(serde::Deserialize)]
struct RenderQuery {
    module: String,
    component: String,
    #[serde(default)]
    params: Option<String>,
}

async fn handle_render(
    State(state): State<AppState>,
    axum::extract::Query(query): axum::extract::Query<RenderQuery>,
) -> Response<Body> {
    // Parse the params JSON string
    let params: std::collections::HashMap<String, serde_json::Value> = match &query.params {
        Some(params_str) => match serde_json::from_str(params_str) {
            Ok(p) => p,
            Err(e) => {
                return Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .header("Content-Type", "text/html")
                    .body(Body::from(format!("Invalid params JSON: {}", e)))
                    .unwrap();
            }
        },
        None => std::collections::HashMap::new(),
    };
    let render_start = std::time::Instant::now();
    log_info!(
        "render",
        step = "enter",
        module = query.module.clone(),
        entrypoint = query.component.clone(),
    );

    let program = state.program.read().unwrap();

    // Get the CSS content from state
    let css = state.tailwind_css.read().unwrap();
    let css_content = css.as_deref();

    let entrypoint_name_for_log = query.component.clone();

    // Parse module name
    let module_name = match ModuleName::new(&query.module) {
        Ok(name) => name,
        Err(e) => {
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(format!("Invalid module name: {}", e)))
                .unwrap();
        }
    };

    // Parse component name
    let component_name = match ComponentName::new(query.component.clone()) {
        Ok(name) => name,
        Err(e) => {
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(format!("Invalid component name: {}", e)))
                .unwrap();
        }
    };

    // Check for compilation errors
    let mut error_output_parts = Vec::new();
    let annotator = DocumentAnnotator::new()
        .with_label("error")
        .with_lines_before(1)
        .with_location();

    // Check for parse errors
    for (module_name, errors) in program.get_parse_errors() {
        if !errors.is_empty() {
            let filename = format!("{}.hop", module_name);
            error_output_parts.push(annotator.annotate(Some(&filename), errors.iter()));
        }
    }

    // Check for type errors if there are no parse errors
    if error_output_parts.is_empty() {
        for (module_name, errors) in program.get_type_errors() {
            if !errors.is_empty() {
                let filename = format!("{}.hop", module_name);
                error_output_parts.push(annotator.annotate(Some(&filename), errors));
            }
        }
    }

    if !error_output_parts.is_empty() {
        let error_html = frontend::overlay(frontend::OverlayParams {
            message: &error_output_parts.join("\n"),
        });
        return Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "text/html")
            .body(Body::from(error_html))
            .unwrap();
    }

    let result = match program.evaluate_entrypoint(
        &module_name,
        &component_name,
        params,
        css_content,
        true, // skip_optimization for faster hot-reload
    ) {
        Ok(html) => Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "text/html")
            .body(Body::from(html))
            .unwrap(),
        Err(e) => Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "text/html")
            .body(Body::from(format!("Error rendering component: {}", e)))
            .unwrap(),
    };

    log_info!(
        "render",
        step = "exit",
        entrypoint = entrypoint_name_for_log,
        duration = format!("{:?}", render_start.elapsed()),
    );

    result
}

pub fn create_router() -> axum::Router<AppState> {
    use axum::routing::get;
    use tower_http::cors::{Any, CorsLayer};

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    axum::Router::new()
        .route("/development_mode.js", get(handle_development_mode_js))
        .route("/event_source", get(handle_event_source))
        .route("/render", get(handle_render))
        .route("/program", get(handle_program))
        .layer(cors)
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use crate::{document::Document, hop::symbols::module_name::ModuleName};
    use axum_test::TestServer;
    use expect_test::expect;
    use simple_txtar::Archive;

    fn create_test_server(input: &str) -> TestServer {
        let archive = Archive::from(input);
        let mut modules = HashMap::new();
        for file in archive.iter() {
            let module_name = ModuleName::new(&file.name.replace(".hop", "")).unwrap();
            modules.insert(module_name, Document::new(file.content.clone()));
        }
        let program = Program::new(modules);
        let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);

        let app_state = AppState {
            program: Arc::new(RwLock::new(program)),
            reload_channel,
            tailwind_css: Arc::new(RwLock::new(None)),
        };

        let router = axum::Router::new()
            .route("/render", axum::routing::get(handle_render))
            .route("/program", axum::routing::get(handle_program))
            .with_state(app_state);

        TestServer::new(router).unwrap()
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_with_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String, title: String) {
              <h1>{title}</h1>
              <p>Hello, {name}!</p>
            }
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "test")
            .add_query_param("component", "GreetingComp")
            .add_query_param("params", r#"{"name":"Alice","title":"Welcome"}"#)
            .await;

        response.assert_status_ok();
        expect![[r#"<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><h1>Welcome</h1><p>Hello, Alice!</p></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_without_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "test")
            .add_query_param("component", "SimpleComp")
            .await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div>Simple content</div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_that_references_a_component_in_another_module() {
        let server = create_test_server(indoc::indoc! {r#"
            -- components.hop --
            <Button {label: String}>
              <button>{label}</button>
            </Button>

            -- page.hop --
            import components::Button

            entrypoint Page() {
              <div><Button label="Click me" /></div>
            }
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "page")
            .add_query_param("component", "Page")
            .await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div><button>Click me</button></div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_asked_to_render_a_component_that_does_not_exist()
     {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String) {
              <p>Hello, {name}!</p>
            }

            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "test")
            .add_query_param("component", "NonExistent")
            .await;

        response.assert_status_bad_request();
        expect!["Error rendering component: Entrypoint 'NonExistent' not found in module 'test'. Available entrypoints: GreetingComp, SimpleComp"]
            .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_receiving_invalid_params_json() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "test")
            .add_query_param("component", "SimpleComp")
            .add_query_param("params", "invalid-json")
            .await;

        response.assert_status_bad_request();

        expect!["Invalid params JSON: expected value at line 1 column 1"]
            .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_parse_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            <GoodComp>
              <div>This is fine</div>
            </GoodComp>

            -- broken.hop --
            <BrokenComp>
              <div>Broken
            </BrokenComp>
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "good")
            .add_query_param("component", "GoodComp")
            .await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Unclosed &lt;div&gt;"));
        assert!(body.contains("broken.hop (line 2, col 4)"));
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_type_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            <GoodComp>
              <div>This is fine</div>
            </GoodComp>

            -- test.hop --
            <Foo {name: String}>
              <p>{name}</p>
            </Foo>

            <Bar>
              <Foo name={undefined_variable} />
            </Bar>
        "#});

        let response = server
            .get("/render")
            .add_query_param("module", "good")
            .add_query_param("component", "GoodComp")
            .await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Undefined variable: undefined_variable"));
        assert!(body.contains("test.hop (line 6, col 14)"));
    }
}
