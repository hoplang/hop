use super::frontend;
use crate::hop::program::Program;
use crate::hop::symbols::component_name::ComponentName;
use crate::hop::symbols::module_name::ModuleName;
use crate::log_info;
use crate::document::DocumentAnnotator;
use axum::body::Body;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::Response;
use std::sync::{Arc, RwLock};

/// Find which module contains a given entrypoint.
/// Returns the module name if found, or an error message listing all available entrypoints.
fn find_module_for_entrypoint(program: &Program, entrypoint: &str) -> Result<ModuleName, String> {
    let mut all_entrypoints = Vec::new();

    for (module_name, ast) in program.get_typed_modules() {
        for ep in ast.get_entrypoint_declarations() {
            if ep.name.as_str() == entrypoint {
                return Ok(module_name.clone());
            }
            all_entrypoints.push(ep.name.to_string());
        }
    }

    all_entrypoints.sort();
    Err(format!(
        "Entrypoint '{}' not found. Available entrypoints: {}",
        entrypoint,
        all_entrypoints.join(", ")
    ))
}

#[derive(Clone)]
pub struct AppState {
    // The compiled hop program.
    pub program: Arc<RwLock<Program>>,

    // Reload channel where the file watchers send hot-reload events.
    // These events are propagated to the event stream listeners.
    pub reload_channel: tokio::sync::broadcast::Sender<()>,

    // The CSS generated by tailwind.
    pub tailwind_css: Arc<RwLock<Option<String>>>,
}

async fn handle_index(State(state): State<AppState>) -> Response<Body> {
    let program = state.program.read().unwrap();

    let mut entrypoints = Vec::new();
    for (module_name, ast) in program.get_typed_modules() {
        for ep in ast.get_entrypoint_declarations() {
            entrypoints.push(frontend::EntrypointData {
                name: ep.name.to_string(),
                module: format!("{}.hop", module_name),
            });
        }
    }

    let html = frontend::index(&entrypoints);
    Response::builder()
        .header("Content-Type", "text/html")
        .body(Body::from(html))
        .unwrap()
}

async fn handle_development_mode_js() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "application/javascript")
        .header("Cache-Control", "public, max-age=31536000, immutable")
        .body(Body::from(include_str!("./js/development_mode.js")))
        .unwrap()
}

async fn handle_idiomorph_js() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "application/javascript")
        .header("Cache-Control", "public, max-age=31536000, immutable")
        .body(Body::from(include_str!("./js/idiomorph.js")))
        .unwrap()
}

async fn handle_hmr() -> Response<Body> {
    Response::builder()
        .header("Content-Type", "text/html")
        .body(Body::from(
            r#"<!DOCTYPE html>
<script type="module" src="/development_mode.js"></script>"#,
        ))
        .unwrap()
}

async fn handle_preview(
    axum::extract::Path(entrypoint): axum::extract::Path<String>,
) -> Response<Body> {
    let iframe_src = format!("/api/preview/{}", entrypoint);
    let html = frontend::preview(&entrypoint, &iframe_src);
    Response::builder()
        .header("Content-Type", "text/html")
        .body(Body::from(html))
        .unwrap()
}

async fn handle_event_source(
    State(state): State<AppState>,
) -> axum::response::sse::Sse<
    impl tokio_stream::Stream<Item = Result<axum::response::sse::Event, axum::Error>>,
> {
    use axum::response::sse::{Event, Sse};
    use std::sync::atomic::{AtomicU64, Ordering};
    use tokio_stream::StreamExt;

    static CONNECTION_ID: AtomicU64 = AtomicU64::new(0);
    let id = CONNECTION_ID.fetch_add(1, Ordering::Relaxed);

    log_info!("sse", event = "connected", client_id = id);

    Sse::new(
        tokio_stream::wrappers::BroadcastStream::new(state.reload_channel.subscribe()).map(
            move |_| {
                log_info!("sse", event = "reload", client_id = id);
                Ok::<Event, axum::Error>(Event::default().data("reload"))
            },
        ),
    )
}

#[derive(serde::Deserialize)]
struct RenderQuery {
    #[serde(default)]
    params: Option<String>, // JSON-encoded params
}

async fn handle_render(
    State(state): State<AppState>,
    axum::extract::Path(entrypoint): axum::extract::Path<String>,
    axum::extract::Query(query): axum::extract::Query<RenderQuery>,
) -> Response<Body> {
    // Parse params from query string (JSON-encoded)
    let params: std::collections::HashMap<String, serde_json::Value> = match &query.params {
        Some(params_str) => match serde_json::from_str(params_str) {
            Ok(p) => p,
            Err(e) => {
                let error_html = frontend::overlay(&format!("Invalid params JSON: {}", e));
                return Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .header("Content-Type", "text/html")
                    .body(Body::from(error_html))
                    .unwrap();
            }
        },
        None => std::collections::HashMap::new(),
    };

    let render_start = std::time::Instant::now();
    log_info!(
        "render",
        step = "enter",
        entrypoint = entrypoint.clone(),
    );

    let program = state.program.read().unwrap();

    // Get the CSS content from state
    let css = state.tailwind_css.read().unwrap();
    let css_content = css.as_deref();

    let entrypoint_name_for_log = entrypoint.clone();

    // Find which module contains this entrypoint
    let module_name = match find_module_for_entrypoint(&program, &entrypoint) {
        Ok(name) => name,
        Err(e) => {
            let error_html = frontend::overlay(&e);
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(error_html))
                .unwrap();
        }
    };

    // Parse entrypoint name
    let entrypoint_name = match ComponentName::new(entrypoint.clone()) {
        Ok(name) => name,
        Err(e) => {
            let error_html = frontend::overlay(&format!("Invalid entrypoint name: {}", e));
            return Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(error_html))
                .unwrap();
        }
    };

    // Check for compilation errors
    let mut error_output_parts = Vec::new();
    let annotator = DocumentAnnotator::new()
        .with_label("error")
        .with_lines_before(1)
        .with_location();

    // Check for parse errors
    for (module_name, errors) in program.get_parse_errors() {
        if !errors.is_empty() {
            let filename = format!("{}.hop", module_name);
            error_output_parts.push(annotator.annotate(Some(&filename), errors.iter()));
        }
    }

    // Check for type errors if there are no parse errors
    if error_output_parts.is_empty() {
        for (module_name, errors) in program.get_type_errors() {
            if !errors.is_empty() {
                let filename = format!("{}.hop", module_name);
                error_output_parts.push(annotator.annotate(Some(&filename), errors));
            }
        }
    }

    if !error_output_parts.is_empty() {
        let error_html = frontend::overlay(&error_output_parts.join("\n"));
        return Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("Content-Type", "text/html")
            .body(Body::from(error_html))
            .unwrap();
    }

    let result = match program.evaluate_entrypoint(
        &module_name,
        &entrypoint_name,
        params,
        css_content,
        true, // skip_optimization for faster hot-reload
    ) {
        Ok(html) => Response::builder()
            .status(StatusCode::OK)
            .header("Content-Type", "text/html")
            .body(Body::from(html))
            .unwrap(),
        Err(e) => {
            let error_html = frontend::overlay(&format!("Error rendering component: {}", e));
            Response::builder()
                .status(StatusCode::BAD_REQUEST)
                .header("Content-Type", "text/html")
                .body(Body::from(error_html))
                .unwrap()
        }
    };

    log_info!(
        "render",
        step = "exit",
        entrypoint = entrypoint_name_for_log,
        duration = format!("{:?}", render_start.elapsed()),
    );

    result
}

pub fn create_router() -> axum::Router<AppState> {
    use axum::routing::get;
    use tower_http::cors::{Any, CorsLayer};

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    axum::Router::new()
        .route("/", get(handle_index))
        .route("/development_mode.js", get(handle_development_mode_js))
        .route("/idiomorph.js", get(handle_idiomorph_js))
        .route("/api/events", get(handle_event_source))
        .route("/api/render/{entrypoint}", get(handle_render))
        .route("/api/preview/{entrypoint}", get(handle_hmr))
        .route("/preview/{entrypoint}", get(handle_preview))
        .layer(cors)
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use axum::routing::get;
    use crate::{document::Document, hop::symbols::module_name::ModuleName};
    use axum_test::TestServer;
    use expect_test::expect;
    use simple_txtar::Archive;

    fn create_test_server(input: &str) -> TestServer {
        let archive = Archive::from(input);
        let mut modules = HashMap::new();
        for file in archive.iter() {
            let module_name = ModuleName::new(&file.name.replace(".hop", "")).unwrap();
            modules.insert(module_name, Document::new(file.content.clone()));
        }
        let program = Program::new(modules);
        let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);

        let app_state = AppState {
            program: Arc::new(RwLock::new(program)),
            reload_channel,
            tailwind_css: Arc::new(RwLock::new(None)),
        };

        let router = axum::Router::new()
            .route("/render/{entrypoint}", get(handle_render))
            .with_state(app_state);

        TestServer::new(router).unwrap()
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_with_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String, title: String) {
              <h1>{title}</h1>
              <p>Hello, {name}!</p>
            }
        "#});

        let params = serde_json::json!({"name": "Alice", "title": "Welcome"});
        let url = format!(
            "/render/GreetingComp?params={}",
            urlencoding::encode(&params.to_string())
        );
        let response = server.get(&url).await;

        response.assert_status_ok();
        expect![[r#"<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><h1>Welcome</h1><p>Hello, Alice!</p></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_without_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server.get("/render/SimpleComp").await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div>Simple content</div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_that_references_a_component_in_another_module() {
        let server = create_test_server(indoc::indoc! {r#"
            -- components.hop --
            <Button {label: String}>
              <button>{label}</button>
            </Button>

            -- page.hop --
            import components::Button

            entrypoint Page() {
              <div><Button label="Click me" /></div>
            }
        "#});

        let response = server.get("/render/Page").await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div><button>Click me</button></div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_asked_to_render_an_entrypoint_that_does_not_exist()
     {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String) {
              <p>Hello, {name}!</p>
            }

            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server.get("/render/NonExistent").await;

        response.assert_status_bad_request();
        assert!(response.text().contains(
            "Entrypoint &#39;NonExistent&#39; not found. Available entrypoints: GreetingComp, SimpleComp"
        ));
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_receiving_invalid_params_json() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server
            .get("/render/SimpleComp?params=invalid-json")
            .await;

        response.assert_status_bad_request();
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_parse_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            entrypoint GoodComp() {
              <div>This is fine</div>
            }

            -- broken.hop --
            <BrokenComp>
              <div>Broken
            </BrokenComp>
        "#});

        let response = server.get("/render/GoodComp").await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Unclosed &lt;div&gt;"));
        assert!(body.contains("broken.hop (line 2, col 4)"));
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_type_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            entrypoint GoodComp() {
              <div>This is fine</div>
            }

            -- test.hop --
            <Foo {name: String}>
              <p>{name}</p>
            </Foo>

            <Bar>
              <Foo name={undefined_variable} />
            </Bar>
        "#});

        let response = server.get("/render/GoodComp").await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Undefined variable: undefined_variable"));
        assert!(body.contains("test.hop (line 6, col 14)"));
    }
}
