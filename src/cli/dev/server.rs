use super::frontend;
use crate::document::DocumentAnnotator;
use crate::dop::symbols::type_name::TypeName;
use crate::hop::program::Program;
use crate::log_info;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use std::sync::{Arc, RwLock};

/// HTML response with 200 OK status.
struct Html(String);

impl IntoResponse for Html {
    fn into_response(self) -> Response {
        Response::builder()
            .header("content-type", "text/html")
            .body(self.0.into())
            .unwrap()
    }
}

/// Error overlay response with 400 Bad Request status.
struct ErrorOverlay(String);

impl IntoResponse for ErrorOverlay {
    fn into_response(self) -> Response {
        Response::builder()
            .status(StatusCode::BAD_REQUEST)
            .header("content-type", "text/html")
            .body(frontend::overlay(&self.0).into())
            .unwrap()
    }
}

/// JavaScript response with immutable cache headers.
struct ImmutableJs(&'static str);

impl IntoResponse for ImmutableJs {
    fn into_response(self) -> Response {
        Response::builder()
            .header("content-type", "application/javascript")
            .header("cache-control", "public, max-age=31536000, immutable")
            .body(self.0.into())
            .unwrap()
    }
}

#[derive(Clone)]
pub struct AppState {
    // The compiled hop program.
    pub program: Arc<RwLock<Program>>,

    // Reload channel where the file watchers send hot-reload events.
    // These events are propagated to the event stream listeners.
    pub reload_channel: tokio::sync::broadcast::Sender<()>,

    // The CSS generated by tailwind.
    pub tailwind_css: Arc<RwLock<Option<String>>>,
}

async fn handle_index(State(state): State<AppState>) -> Html {
    let program = state.program.read().unwrap();

    let mut entrypoints = Vec::new();
    for (module_id, ast) in program.get_typed_modules() {
        for ep in ast.get_entrypoint_declarations() {
            entrypoints.push(frontend::EntrypointData {
                name: ep.name.to_string(),
                module: format!("{}.hop", module_id),
            });
        }
    }

    Html(frontend::index(&entrypoints))
}

async fn handle_development_mode_js() -> ImmutableJs {
    ImmutableJs(include_str!("./js/development_mode.js"))
}

async fn handle_idiomorph_js() -> ImmutableJs {
    ImmutableJs(include_str!("./js/idiomorph.js"))
}

async fn handle_hmr() -> Html {
    Html(
        r#"<!DOCTYPE html>
<script type="module" src="/development_mode.js"></script>"#
            .to_string(),
    )
}

#[derive(serde::Deserialize)]
struct PreviewQuery {
    #[serde(default)]
    device: Option<String>,
}

async fn handle_preview(
    axum::extract::Path(entrypoint): axum::extract::Path<String>,
    axum::extract::Query(query): axum::extract::Query<PreviewQuery>,
) -> Result<Html, ErrorOverlay> {
    let device = match query.device.as_deref() {
        Some("mobile") => frontend::Device::Mobile,
        Some("desktop") | None => frontend::Device::Desktop,
        Some(invalid) => {
            return Err(ErrorOverlay(format!("Invalid device: {}", invalid)));
        }
    };
    let iframe_src = format!("/api/preview/{}", entrypoint);
    Ok(Html(frontend::preview(&entrypoint, &iframe_src, &device)))
}

async fn handle_event_source(
    State(state): State<AppState>,
) -> axum::response::sse::Sse<
    impl tokio_stream::Stream<Item = Result<axum::response::sse::Event, axum::Error>>,
> {
    use axum::response::sse::{Event, Sse};
    use std::sync::atomic::{AtomicU64, Ordering};
    use tokio_stream::StreamExt;

    static CONNECTION_ID: AtomicU64 = AtomicU64::new(0);
    let id = CONNECTION_ID.fetch_add(1, Ordering::Relaxed);

    log_info!("sse", event = "connected", client_id = id);

    Sse::new(
        tokio_stream::wrappers::BroadcastStream::new(state.reload_channel.subscribe()).map(
            move |_| {
                log_info!("sse", event = "reload", client_id = id);
                Ok::<Event, axum::Error>(Event::default().data("reload"))
            },
        ),
    )
}

#[derive(serde::Deserialize)]
struct RenderQuery {
    #[serde(default)]
    params: Option<String>, // JSON-encoded params
}

async fn handle_render(
    State(state): State<AppState>,
    axum::extract::Path(entrypoint): axum::extract::Path<String>,
    axum::extract::Query(query): axum::extract::Query<RenderQuery>,
) -> Result<Html, ErrorOverlay> {
    // Parse params from query string (JSON-encoded)
    let params: std::collections::HashMap<String, serde_json::Value> = match &query.params {
        Some(params_str) => serde_json::from_str(params_str)
            .map_err(|e| ErrorOverlay(format!("Invalid params JSON: {}", e)))?,
        None => std::collections::HashMap::new(),
    };

    let render_start = std::time::Instant::now();
    log_info!("render", step = "enter", entrypoint = entrypoint.clone(),);

    let program = state.program.read().unwrap();

    // Get the CSS content from state
    let css = state.tailwind_css.read().unwrap();
    let css_content = css.as_deref();

    // Find which module contains this entrypoint
    let module_id = program
        .find_module_for_entrypoint(&entrypoint)
        .map_err(ErrorOverlay)?;

    // Parse entrypoint name
    let entrypoint_name = TypeName::new(&entrypoint)
        .map_err(|e| ErrorOverlay(format!("Invalid entrypoint name: {}", e)))?;

    // Check for compilation errors
    let mut error_output_parts = Vec::new();
    let annotator = DocumentAnnotator::new()
        .with_label("error")
        .with_lines_before(1)
        .with_location();

    // Check for parse errors
    for (module_id, errors) in program.get_parse_errors() {
        if !errors.is_empty() {
            let filename = format!("{}.hop", module_id);
            error_output_parts.push(annotator.annotate(Some(&filename), errors.iter()));
        }
    }

    // Check for type errors if there are no parse errors
    if error_output_parts.is_empty() {
        for (module_id, errors) in program.get_type_errors() {
            if !errors.is_empty() {
                let filename = format!("{}.hop", module_id);
                error_output_parts.push(annotator.annotate(Some(&filename), errors));
            }
        }
    }

    if !error_output_parts.is_empty() {
        return Err(ErrorOverlay(error_output_parts.join("\n")));
    }

    let result = program
        .evaluate_entrypoint(
            &module_id,
            &entrypoint_name,
            params,
            css_content,
            true, // skip_optimization for faster hot-reload
        )
        .map(Html)
        .map_err(|e| ErrorOverlay(format!("Error rendering component: {}", e)));

    log_info!(
        "render",
        step = "exit",
        entrypoint = entrypoint,
        duration = format!("{:?}", render_start.elapsed()),
    );

    result
}

pub fn create_router() -> axum::Router<AppState> {
    use axum::routing::get;
    use tower_http::cors::{Any, CorsLayer};

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    axum::Router::new()
        .route("/", get(handle_index))
        .route("/development_mode.js", get(handle_development_mode_js))
        .route("/idiomorph.js", get(handle_idiomorph_js))
        .route("/api/events", get(handle_event_source))
        .route("/api/render/{entrypoint}", get(handle_render))
        .route("/api/preview/{entrypoint}", get(handle_hmr))
        .route("/preview/{entrypoint}", get(handle_preview))
        .layer(cors)
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::*;
    use crate::{document::Document, hop::symbols::module_id::ModuleId};
    use axum::routing::get;
    use axum_test::TestServer;
    use expect_test::expect;
    use simple_txtar::Archive;

    fn create_test_server(input: &str) -> TestServer {
        let archive = Archive::from(input);
        let mut modules = HashMap::new();
        for file in archive.iter() {
            let module_id =
                ModuleId::new(&file.name.replace(".hop", "").replace('/', "::")).unwrap();
            modules.insert(
                module_id.clone(),
                Document::new(module_id, file.content.clone()),
            );
        }
        let program = Program::new(modules);
        let (reload_channel, _) = tokio::sync::broadcast::channel::<()>(100);

        let app_state = AppState {
            program: Arc::new(RwLock::new(program)),
            reload_channel,
            tailwind_css: Arc::new(RwLock::new(None)),
        };

        let router = axum::Router::new()
            .route("/render/{entrypoint}", get(handle_render))
            .with_state(app_state);

        TestServer::new(router).unwrap()
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_with_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String, title: String) {
              <h1>{title}</h1>
              <p>Hello, {name}!</p>
            }
        "#});

        let params = serde_json::json!({"name": "Alice", "title": "Welcome"});
        let url = format!(
            "/render/GreetingComp?params={}",
            urlencoding::encode(&params.to_string())
        );
        let response = server.get(&url).await;

        response.assert_status_ok();
        expect![[r#"<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><h1>Welcome</h1><p>Hello, Alice!</p></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_without_props() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server.get("/render/SimpleComp").await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div>Simple content</div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_correctly_render_a_component_that_references_a_component_in_another_module() {
        let server = create_test_server(indoc::indoc! {r#"
            -- components.hop --
            <Button {label: String}>
              <button>{label}</button>
            </Button>

            -- page.hop --
            import components::Button

            entrypoint Page() {
              <div><Button label="Click me" /></div>
            }
        "#});

        let response = server.get("/render/Page").await;

        response.assert_status_ok();
        expect![[r#"
            <!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div><button>Click me</button></div></body></html>"#]]
        .assert_eq(&response.text());
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_asked_to_render_an_entrypoint_that_does_not_exist()
     {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint GreetingComp(name: String) {
              <p>Hello, {name}!</p>
            }

            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server.get("/render/NonExistent").await;

        response.assert_status_bad_request();
        assert!(response.text().contains(
            "Entrypoint &#39;NonExistent&#39; not found. Available entrypoints: GreetingComp, SimpleComp"
        ));
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_receiving_invalid_params_json() {
        let server = create_test_server(indoc::indoc! {r#"
            -- test.hop --
            entrypoint SimpleComp() {
              <div>Simple content</div>
            }
        "#});

        let response = server.get("/render/SimpleComp?params=invalid-json").await;

        response.assert_status_bad_request();
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_parse_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            entrypoint GoodComp() {
              <div>This is fine</div>
            }

            -- broken.hop --
            <BrokenComp>
              <div>Broken
            </BrokenComp>
        "#});

        let response = server.get("/render/GoodComp").await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Unclosed &lt;div&gt;"));
        assert!(body.contains("broken.hop (line 2, col 4)"));
    }

    #[tokio::test]
    async fn should_return_status_bad_request_for_render_when_any_module_contains_type_errors() {
        let server = create_test_server(indoc::indoc! {r#"
            -- good.hop --
            entrypoint GoodComp() {
              <div>This is fine</div>
            }

            -- test.hop --
            <Foo {name: String}>
              <p>{name}</p>
            </Foo>

            <Bar>
              <Foo name={undefined_variable} />
            </Bar>
        "#});

        let response = server.get("/render/GoodComp").await;

        response.assert_status_bad_request();
        let body = response.text();
        assert!(body.contains("error: Undefined variable: undefined_variable"));
        assert!(body.contains("test.hop (line 6, col 14)"));
    }
}
